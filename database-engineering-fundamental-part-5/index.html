<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Part 5: Database Engineering Fundamentals" /><meta name="author" content="Pravin Tripathi" /><meta property="og:locale" content="en" /><meta name="description" content="Database Security Enabling TLS and SSL in postgres.conf file don’t allow larger query as if around 14MB, it will crash server" /><meta property="og:description" content="Database Security Enabling TLS and SSL in postgres.conf file don’t allow larger query as if around 14MB, it will crash server" /><link rel="canonical" href="https://pravin.dev/database-engineering-fundamental-part-5/" /><meta property="og:url" content="https://pravin.dev/database-engineering-fundamental-part-5/" /><meta property="og:site_name" content="Pravin on Software" /><meta property="og:image" content="https://pravin.dev/header.png" /><meta property="og:image:height" content="900" /><meta property="og:image:width" content="1600" /><meta property="og:image:alt" content="Generated using Copilot" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-05T01:00:00+05:30" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://pravin.dev/header.png" /><meta name="twitter:image:alt" content="Generated using Copilot" /><meta property="twitter:title" content="Part 5: Database Engineering Fundamentals" /><meta name="twitter:site" content="@pravin_yo" /><meta name="twitter:creator" content="@pravin_yo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pravin Tripathi","url":"https://www.linkedin.com/in/pravin-r-tripathi"},"dateModified":"2025-03-22T16:02:56+05:30","datePublished":"2024-07-05T01:00:00+05:30","description":"Database Security Enabling TLS and SSL in postgres.conf file don’t allow larger query as if around 14MB, it will crash server","headline":"Part 5: Database Engineering Fundamentals","image":{"width":1600,"height":900,"alt":"Generated using Copilot","url":"https://pravin.dev/header.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pravin.dev/database-engineering-fundamental-part-5/"},"url":"https://pravin.dev/database-engineering-fundamental-part-5/"}</script><title>Part 5: Database Engineering Fundamentals | Pravin on Software</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Pravin on Software"><meta name="application-name" content="Pravin on Software"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Pravin on Software</a></div><div class="site-subtitle font-italic">My Learning and Experiments in Software Engineering</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/pravinyo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/pravin_yo" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['pravinyo12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Part 5: Database Engineering Fundamentals</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Part 5: Database Engineering Fundamentals</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1720121400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 5, 2024 </em> </span> <span> Updated <em class="" data-ts="1742639576" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 22, 2025 </em> </span><div class="mt-3 mb-3"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 900'%3E%3C/svg%3E" data-src="/assets/img/database-engineering-fundamental-part-5/header.png" class="preview-img bg" alt="Generated using Copilot" width="1600" height="900" data-proofer-ignore><figcaption class="pt-2 pb-2">Generated using Copilot</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4755 words"> <em>26 min</em> read</span></div></div></div><div class="post-content"><h2 id="database-security"><span class="mr-2">Database Security</span><a href="#database-security" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Enabling TLS and SSL in postgres.conf file<li>don’t allow larger query as if around 14MB, it will crash server</ul><h2 id="best-practices-working-with-rest--databases"><span class="mr-2">Best Practices Working with REST &amp; Databases</span><a href="#best-practices-working-with-rest--databases" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>give different access to different user/client/application<li>table own by one user should not be modified by another table.<li>better to use database management tools</ul><h2 id="homomorphic-encryption"><span class="mr-2">Homomorphic Encryption</span><a href="#homomorphic-encryption" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Why we can’t always encrypt?</p><ul><li>Database Queries can only be performed on plain text<li>Analysis, Indexing, tuning<li>Applications must read data to process it<li>TLS Termination Layer 7 Reverse Proxies and Load Balancing</ul><h2 id="meet-homomorphic-encryption"><span class="mr-2">Meet Homomorphic Encryption!</span><a href="#meet-homomorphic-encryption" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Ability to perform arithmetic operations on encrypted data<li>No need to decrypt!<li>You can query a database that is encrypted!<li>Layer 7 Reverse Proxies don’t have to terminate TLS, can route traffic based on rules without decrypting traffic<li>Databases can index and optimize without decrypting data</ul><p>Example, https://github.com/IBM/fhe-toolkit-linux it is not Production ready yet. It takes 2 mins to fetch record in smaller DB.</p><h2 id="questions-and-answers"><span class="mr-2">Questions and Answers</span><a href="#questions-and-answers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="heap-index-scan-instead-of-index-only-scan"><span class="mr-2">Heap index scan instead of index only scan?</span><a href="#heap-index-scan-instead-of-index-only-scan" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>It is possible that statistics is not updated which causes the database to think based on incorrect information. This statistics is used by database to plan the execution and decide the index that it will use to look for the required data.</p><p>In order to update statistics, we have to execute vacuum command in the database to trigger clean up of the unused page and also updation of the statistics.</p><h3 id="what-is-cost-in-the-execution-plan"><span class="mr-2">What is cost in the execution plan?</span><a href="#what-is-cost-in-the-execution-plan" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>It is effort/cost required by Database to fetch the data. It is not in milliseconds but number. higher means more cost. There is a possibility that cost in execution plan can be higher than the execution plan. It is probably due to statistics not been update. Well we have to execute vacuum command.</p><h3 id="all-isolation-levels"><span class="mr-2">All Isolation levels</span><a href="#all-isolation-levels" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>PostgreSQL supports several isolation levels that control the visibility of data changes to other transactions. The isolation levels define how transactions interact with each other when reading and writing data, ensuring consistency and correctness of operations in multi-user environments.</p><p>Here’s a breakdown of the <strong>four main isolation levels</strong> in PostgreSQL:</p><ol><li><strong>Read Uncommitted</strong> (Not supported in PostgreSQL, but conceptually available in other DBMS like MySQL or SQL Server).<li><strong>Read Committed</strong> (default in PostgreSQL).<li><strong>Repeatable Read</strong>.<li><strong>Serializable</strong>.</ol><hr /><h3 id="1-read-committed-default-in-postgresql"><span class="mr-2">1. <strong>Read Committed</strong> (Default in PostgreSQL)</span><a href="#1-read-committed-default-in-postgresql" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In the <strong>Read Committed</strong> isolation level, each query within a transaction sees a consistent view of the database, but data changes made by other transactions can be visible during the execution of the transaction. This means:</p><ul><li>If two transactions run concurrently, one transaction might see the changes made by the other <strong>before</strong> it commits.</ul><p><strong>Example Scenario:</strong></p><ul><li>Transaction 1 starts and updates a record.<li>Transaction 2 starts and reads the same record, seeing the changes made by Transaction 1, even though Transaction 1 hasn’t committed yet.</ul><h3 id="2-repeatable-read"><span class="mr-2">2. <strong>Repeatable Read</strong></span><a href="#2-repeatable-read" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In <strong>Repeatable Read</strong>, the database guarantees that any data read by a transaction will remain the same throughout the entire transaction. This prevents “non-repeatable reads,” where a transaction could read different values for the same data if another transaction modifies it.</p><ul><li><strong>Phantom Reads</strong> are still possible in this isolation level, which means that if new rows are added to the database, they might not be visible to the current transaction.</ul><p><strong>Example Scenario:</strong></p><ul><li>Transaction 1 starts and reads a record.<li>Transaction 2 starts and updates the same record.<li>Transaction 1 reads the record again and sees the same value as initially read.</ul><h3 id="3-serializable"><span class="mr-2">3. <strong>Serializable</strong></span><a href="#3-serializable" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The <strong>Serializable</strong> isolation level ensures the strictest consistency, where transactions are executed in a way that they could be serially ordered (i.e., one after the other) without conflict. This level prevents <strong>dirty reads</strong>, <strong>non-repeatable reads</strong>, and <strong>phantom reads</strong>.</p><ul><li>This isolation level effectively serializes access to the data, as if the transactions were run sequentially, ensuring that the final database state is the same as if the transactions were processed one by one, without overlap.</ul><p><strong>Example Scenario:</strong></p><ul><li>Transaction 1 starts and reads a record.<li>Transaction 2 starts and attempts to update the same record but is blocked until Transaction 1 is completed.</ul><hr /><h3 id="key-differences-between-isolation-levels"><span class="mr-2">Key Differences Between Isolation Levels</span><a href="#key-differences-between-isolation-levels" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th><strong>Isolation Level</strong><th><strong>Dirty Reads</strong><th><strong>Non-Repeatable Reads</strong><th><strong>Phantom Reads</strong><th><strong>Description</strong><tbody><tr><td><strong>Read Uncommitted</strong><td>Yes<td>Yes<td>Yes<td>Transactions can see uncommitted changes from other transactions. (Not supported in PostgreSQL)<tr><td><strong>Read Committed</strong><td>No<td>Yes<td>Yes<td>Transactions see only committed data, but results might change between queries.<tr><td><strong>Repeatable Read</strong><td>No<td>No<td>Yes<td>Transactions see consistent data, but new rows can be inserted, leading to phantom reads.<tr><td><strong>Serializable</strong><td>No<td>No<td>No<td>Transactions are executed as if they were serially ordered, avoiding all anomalies.</table></div><hr /><h3 id="repeatable-read-vs-snapshot-isolation"><span class="mr-2">Repeatable read vs Snapshot Isolation</span><a href="#repeatable-read-vs-snapshot-isolation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In repeatable read, if max value in the table is queried to be found that it will behave different in below scenario,</p><p>If after query, some other transaction insert new record that changes the max score value, then next time execution of same query will return different value. so it is like a phantom read.</p><p>This problem is solved by snapshot isolation level, here it says read rows older than the time it stared the transaction so newer record will not be read. so execution of same query like above will return same value both times.</p><p><code class="language-plaintext highlighter-rouge">In postgres, repeatable read is same as snapshot isolation. basically internal implementation is different.</code> due to versioning it by default solves the phantom read problem</p><h3 id="postgres-is-using-sequence-scan-instead-of-index-scan-on-smaller-table"><span class="mr-2">Postgres is using sequence scan instead of index scan on smaller table.</span><a href="#postgres-is-using-sequence-scan-instead-of-index-scan-on-smaller-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I am using postgresql. I have created a table with 4 columns (id, first_name, last_name, dob), and created an index on id which is a primary key as well. When i do select query like</p><p><code class="language-plaintext highlighter-rouge">select id where id = 2</code></p><p>It is using seq scan rather than index-only scan. What’s the issue here?</p><p>This table has only 7 rows.</p><p><strong>Answer:</strong> Your last statement is why.</p><p>The 7 rows fits nicely in one page in the heap, so in postgres optimizer says hey. The entire table is one page I can just read that page directly instead of cracking up the id index and read the btree and go through the btree complex structure. My guess is the index is never loaded to memory at this stage too because the table is too small and not worth it.</p><p>Add another 10k rows and it the plan will change</p><h3 id="fetching-page-vs-row-in-index"><span class="mr-2"><strong>Fetching page vs row in index</strong></span><a href="#fetching-page-vs-row-in-index" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>where you explain how indexes and table are stored, you mentioned that when we execute sql query, behind the scenes the whole page is fetched and only the row needed is filtered and sent to user. I have 2 questions:</p><p>a) why does it get the whole page, why not just the row since the db now already knows the row location.</p><p>b) How does this work during index? I mean an index will point you to the exact row, so does it still fetches the whole page the row is in?</p><p><strong>Answer:</strong> A) that is how disks work , you can’t fetch one row you have to fetch a “block” this is unlike RAM where you can do byte level addressing. There are new SSDs called ultraram that allows for byte addressability which will allow us to do what you are saying but for now we have to fetch a page and we get multiple rows with it.</p><p>B) the index itself is stored on disk correct? And anything stored in disk has to be stored in pages :) so yes even the index read in pages and we get a bunch of row entries. Of course once a page is in memory you can pull any byte off it.</p><p><strong>Follow-up:</strong> it doesn’t make sense to me that the index is stored on disk !! won’t be better if the index is stored in memory for faster search &amp; access?  idk, if the index is relatively small, won’t it be stored in memory instead?</p><p><strong>Answer:</strong> the indexes are stored in memory but also stored on disk. otherwise if you shutdown the database you will have to recreate all indexes or all tables of all databases which is not feasible</p><p>furthermore you will run out of memory what do you do in that case? do you lose your index.</p><p>you need to store the index on disk and load it on memory for performance</p><h3 id="index-on-column-with-duplicate-values"><span class="mr-2"><strong>Index on column with duplicate values</strong></span><a href="#index-on-column-with-duplicate-values" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>If we are creating index on a column which can have duplicate values then how is it stored in index data structure?</p><p>Does it maintain a key with name as duplicate value and values would be list of rows and corresponding page information?</p><p><strong>Answer:</strong> Good question, databases implements this differently. Postgres for the longest time stored the duplicated values in the index for each key. Then later improved thati in postgres 13 by deduplicating it (k1-(row1,row2,row7)</p><h2 id="instead-of-k1-row1--k1-row2--k1-row7"><span class="mr-2">Instead of k1-row1 / k1-row2 / k1-row7</span><a href="#instead-of-k1-row1--k1-row2--k1-row7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Is indexing a boolean column useful, let’s suppose we have a table which contains a processed flag, as rows are processed, this flag is marked as true/1. However, this table can contain huge number of rows and new rows are inserted with processed=false/0 for processing, so we need to query these columns periodically to process. Is it useful to add index on this column?</p><p><strong>Answer:</strong> this depends on the selectively of the boolean column.</p><p>say you have your processed field,</p><p>if we know that unprocessed rows (processed = 0 ) is FAR less than processed =1 say 1% of the rows are unprocessed then indexing is useful especially if you only query for unprocessed rows</p><p>but if you query for processed rows = 1 you know you will get massive rows and the index will not he as useful.</p><p>remember index is only useful if the rows that you predict to come back are small</p><h2 id="deduplication-of-b-tree-indexes-in-postgresql-13"><span class="mr-2">Deduplication of B-tree Indexes in PostgreSQL 13</span><a href="#deduplication-of-b-tree-indexes-in-postgresql-13" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In PostgreSQL 13, one of the significant changes related to indexing was the improvement in <strong>B-tree index deduplication</strong>. B-trees are a common data structure used for indexing in databases, and they are used by default in PostgreSQL for most index types. B-tree indexes organize data in a balanced tree structure that allows for fast search, insert, and delete operations.</p><p>Previously, when multiple identical values were inserted into a B-tree index (for example, inserting rows with the same key value), each of these duplicate values would take up space in the index, even though they essentially represent the same data in the context of the index. This could lead to inefficient use of disk space and performance issues, especially with large datasets.</p><p>With the introduction of deduplication in PostgreSQL 13, when multiple rows with identical indexed values are inserted, PostgreSQL now eliminates the need for storing duplicate entries in the index. Instead, it only stores the value once and maintains a list of the associated tuple (row) locations. This can significantly improve the efficiency of indexing, reduce index size, and improve performance for certain types of queries that involve duplicate indexed values.</p><h3 id="benefits-of-b-tree-index-deduplication"><span class="mr-2">Benefits of B-tree Index Deduplication</span><a href="#benefits-of-b-tree-index-deduplication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><strong>Reduced Disk Space Usage</strong>: Deduplication reduces the number of entries stored in the index, thereby saving disk space.<li><strong>Improved Performance</strong>: Since the index becomes smaller and more compact, searches, insertions, and deletions involving the indexed column can become faster.<li><strong>Faster Index Maintenance</strong>: When indexes are smaller, PostgreSQL can rebuild and maintain them more efficiently.</ol><h3 id="use-cases"><span class="mr-2">Use Cases</span><a href="#use-cases" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This feature is particularly beneficial for columns where there are many duplicate values, such as:</p><ul><li>Status fields (e.g., active/inactive flags)<li>Gender fields (e.g., “Male”, “Female”)<li>Categorical data (e.g., product categories)</ul><h3 id="technical-details"><span class="mr-2">Technical Details</span><a href="#technical-details" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>The deduplication happens automatically when creating or maintaining B-tree indexes.<li>The database checks for duplicate values when inserting into the index and keeps only one entry for each distinct value.<li>It also stores pointers to the corresponding tuples in the index, so the database can still retrieve the correct rows when queried.</ul><h3 id="scenario-table-of-sales-records"><span class="mr-2">Scenario: Table of Sales Records</span><a href="#scenario-table-of-sales-records" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Let’s consider a table of <strong>sales records</strong>, where we want to create an index on the <code class="language-plaintext highlighter-rouge">product_id</code> column. Many sales records might involve the same product, so there will be lots of duplicate <code class="language-plaintext highlighter-rouge">product_id</code> values.</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">sales</span> <span class="p">(</span>
    <span class="n">sale_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">product_id</span> <span class="nb">INT</span><span class="p">,</span>
    <span class="n">quantity</span> <span class="nb">INT</span><span class="p">,</span>
    <span class="n">sale_date</span> <span class="nb">DATE</span>
<span class="p">);</span>
</pre></table></code></div></div><h3 id="step-1-insert-some-data"><span class="mr-2">Step 1: Insert Some Data</span><a href="#step-1-insert-some-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Let’s say we insert a few rows into the <code class="language-plaintext highlighter-rouge">sales</code> table:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">sales</span> <span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">sale_date</span><span class="p">)</span> <span class="k">VALUES</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'2024-01-01'</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">'2024-01-02'</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">'2024-01-03'</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="s1">'2024-01-04'</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="s1">'2024-01-05'</span><span class="p">);</span>
</pre></table></code></div></div><p>Now, the <strong>sales</strong> table looks like this:</p><div class="table-wrapper"><table><thead><tr><th>sale_id<th>product_id<th>quantity<th>sale_date<tbody><tr><td>1<td>1<td>100<td>2024-01-01<tr><td>2<td>2<td>50<td>2024-01-02<tr><td>3<td>1<td>200<td>2024-01-03<tr><td>4<td>1<td>150<td>2024-01-04<tr><td>5<td>3<td>300<td>2024-01-05</table></div><p>We have a <strong>product_id</strong> of <strong>1</strong> appearing multiple times (for product 1).</p><h3 id="step-2-create-an-index-on-product_id"><span class="mr-2">Step 2: Create an Index on <strong>product_id</strong></span><a href="#step-2-create-an-index-on-product_id" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now, you decide to create an index on the <strong>product_id</strong> column to speed up queries that look for specific products:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_product_id</span> <span class="k">ON</span> <span class="n">sales</span><span class="p">(</span><span class="n">product_id</span><span class="p">);</span>

</pre></table></code></div></div><h3 id="step-3-how-the-index-looks-before-postgresql-13"><span class="mr-2">Step 3: How the Index Looks Before PostgreSQL 13</span><a href="#step-3-how-the-index-looks-before-postgresql-13" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Before PostgreSQL 13, a B-tree index for <code class="language-plaintext highlighter-rouge">product_id</code> would look something like this (with no deduplication):</p><div class="table-wrapper"><table><thead><tr><th>product_id<th>tuple IDs (row pointers)<tbody><tr><td>1<td>(1, 3, 4)<tr><td>2<td>(2)<tr><td>3<td>(5)</table></div><p>Here:</p><ul><li>For <code class="language-plaintext highlighter-rouge">product_id = 1</code>, we store three pointers (to rows 1, 3, and 4) because the same product appears in multiple rows.<li>For <code class="language-plaintext highlighter-rouge">product_id = 2</code>, there is one pointer (to row 2).<li>For <code class="language-plaintext highlighter-rouge">product_id = 3</code>, there is one pointer (to row 5).</ul><h3 id="step-4-deduplication-in-postgresql-13"><span class="mr-2">Step 4: Deduplication in PostgreSQL 13</span><a href="#step-4-deduplication-in-postgresql-13" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In <strong>PostgreSQL 13</strong> (and later), the <strong>deduplication</strong> feature in B-tree indexes changes this process.</p><p>Instead of storing multiple copies of <code class="language-plaintext highlighter-rouge">product_id = 1</code> in the index, <strong>PostgreSQL 13 will store only one entry for each distinct value</strong> in the indexed column, with a list of <strong>tuple pointers</strong> (row IDs) for each occurrence.</p><p>So, after deduplication, the index looks like this:</p><div class="table-wrapper"><table><thead><tr><th>product_id<th>tuple IDs (row pointers)<tbody><tr><td>1<td>(1, 3, 4)<tr><td>2<td>(2)<tr><td>3<td>(5)</table></div><h3 id="explanation-of-deduplication"><span class="mr-2">Explanation of Deduplication:</span><a href="#explanation-of-deduplication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Before deduplication (Pre-PostgreSQL 13)</strong>:<ul><li>The index stored <strong>multiple entries</strong> for the same <code class="language-plaintext highlighter-rouge">product_id</code> if it appeared multiple times. For <code class="language-plaintext highlighter-rouge">product_id = 1</code>, it stored 3 entries, each pointing to a different row.</ul><li><strong>After deduplication (PostgreSQL 13)</strong>:<ul><li>The index stores <strong>only one entry</strong> for <code class="language-plaintext highlighter-rouge">product_id = 1</code>. Instead of multiple entries for each instance of <code class="language-plaintext highlighter-rouge">product_id = 1</code>, it only stores one <code class="language-plaintext highlighter-rouge">product_id = 1</code> with a list of <strong>tuple IDs</strong> (row pointers) that refer to the actual rows where that product appears (rows 1, 3, and 4).</ul></ul><h3 id="step-5-benefits-of-deduplication"><span class="mr-2">Step 5: Benefits of Deduplication</span><a href="#step-5-benefits-of-deduplication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><strong>Reduced Index Size</strong>:<ul><li>In the deduplicated index, <code class="language-plaintext highlighter-rouge">product_id = 1</code> only needs one entry (with a list of row pointers), whereas in the pre-PostgreSQL 13 index, <code class="language-plaintext highlighter-rouge">product_id = 1</code> would have had three separate entries. This reduces the overall size of the index, which is especially important when dealing with large tables with many duplicates.</ul><li><strong>Improved Performance</strong>:<ul><li>Query performance for searches on the indexed column (<code class="language-plaintext highlighter-rouge">product_id</code>) will be faster because the index is smaller and more efficient. For example, a search for <code class="language-plaintext highlighter-rouge">product_id = 1</code> can quickly retrieve the row pointers without needing to traverse multiple entries.</ul><li><strong>More Efficient Insertions/Updates</strong>:<ul><li>When new rows are inserted or existing rows are updated, PostgreSQL doesn’t need to insert multiple copies of the same <code class="language-plaintext highlighter-rouge">product_id</code> in the index. This saves time and resources, improving overall database performance.</ul></ol><h3 id="example-query"><span class="mr-2">Example Query:</span><a href="#example-query" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Let’s say you run a query to find all sales for <code class="language-plaintext highlighter-rouge">product_id = 1</code>:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">sales</span> <span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

</pre></table></code></div></div><p>With the deduplicated index:</p><ul><li>PostgreSQL will find the index entry for <code class="language-plaintext highlighter-rouge">product_id = 1</code>, and since it points to rows 1, 3, and 4, it will directly fetch those rows.</ul><h3 id="conclusion"><span class="mr-2">Conclusion:</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Deduplication in PostgreSQL 13 B-tree indexes significantly reduces index size and improves query performance by ensuring that each distinct value in the indexed column is stored only once in the index, even if it appears multiple times in the table. This is particularly useful in cases where there are many duplicate values in the indexed column.</p><h2 id="lock-with-serializable-isolation"><span class="mr-2"><strong>Lock with serializable isolation</strong></span><a href="#lock-with-serializable-isolation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>You mentioned that serializable isolation level transactions are run one after another. So what’s a point of lock with pessimistically implementation with SELECT FOR UPDATE?</p><p><strong>Answer:</strong> Good question, the serializable isolation level will give you the result of having each transaction run one after the other without actually having the transactions being blocked. The transactions can still run concurrently in serializable isolation level and when the DBMS detects that a change will be out of order it issues an error (serialization failure). This is using optimistic concurrency control.</p><p>With SELECT FOR UPDATE you achieve the serialization by actually blocking the transactions from running concurrently so you will get the same result but its at the cost of concurrency. Plus you won’t fail on other word pessimistic concurrency control</p><p>Summary serialization isolation level uses optimistic concurrency control which can be faster than pessimistic. But can fail and transactions will need to be retried</p><p>Suppose i have products table, i have two outlets of my shop accessing the same database (serializable isolation level)</p><p>Consider two scenarios,</p><p>scenario 1:</p><p>(both transactions start simultaneously)</p><p>T1:</p><p>update QTY of product A</p><p>T2:</p><p>update QTY of product B</p><p>So here i assume that since both the transactions are accessing different rows, they will be ran concurrently</p><p>scenario 2:</p><p>(both transactions start simultaneously)</p><p>T1:</p><p>update QTY of product A</p><p>T2:</p><p>update QTY of product A</p><p>So here i assume that since both the transactions are accessing same row it will be ran concurrently and then DBMS will throw serialization failure error and hence it will fail both the transaction (or will it retry automatically but in a serializable way?)</p><p>because both accessing the same the row the first transaction to update the row holds a FOR UPDATE lock, even in serializable mode.</p><p>so the second transaction will just wait and be blocked. once the first transaction commits the second transaction attempts to update the same row and it will see the the value has changed from its snapshot and it will fail with a serilization error.</p><p>remember that serializable doesn’t force the trans to run one after the other physically. they can still run concurrently as long as this rule is satisfied</p><p>if tx1 read x then tx2 changed it, tx1 will fail to commit</p><p>if tx1 writes something that tx2 then reads that also fails because tx2 is now reading something that has changed. and as a result can’t guarantee the order</p><h2 id="hot-updates-in-postgres-by-design-some-space-in-the-page-is-left-empty-to-accommodate-future-update-in-same-pagelocation"><span class="mr-2">HOT updates in Postgres (by design some space in the page is left empty to accommodate future update in same page/location)</span><a href="#hot-updates-in-postgres-by-design-some-space-in-the-page-is-left-empty-to-accommodate-future-update-in-same-pagelocation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In PostgreSQL, <strong>HOT (Heap-Only Tuple) updates</strong> refer to an optimization technique that aims to reduce the overhead of index updates when modifying a row in a table. The primary goal of HOT updates is to improve <strong>write performance</strong> by avoiding unnecessary index maintenance during certain kinds of row updates.</p><h3 id="what-is-a-hot-update"><span class="mr-2">What is a HOT Update?</span><a href="#what-is-a-hot-update" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A <strong>HOT update</strong> occurs when a row in a table is updated in such a way that it doesn’t require any changes to the <strong>indexes</strong> that reference the row. This is possible when the update:</p><ul><li><strong>Does not affect indexed columns</strong> (i.e., columns that are part of any index).<li>The <strong>row remains physically in the same position</strong> in the table.</ul><p>In this case, PostgreSQL can simply update the tuple in the heap (the main storage of table data) without having to modify the associated index entries. This reduces the need for additional writes to the index, which is often the more expensive part of an update operation.</p><h3 id="how-does-hot-update-work-internally"><span class="mr-2">How Does HOT Update Work Internally?</span><a href="#how-does-hot-update-work-internally" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Internally, PostgreSQL stores table data as <strong>tuples</strong> in a <strong>heap</strong> file. When an update is performed on a row, PostgreSQL typically writes a new version of the row to the heap and marks the old version as “dead” (in a special state called <strong>MVCC</strong>—Multi-Version Concurrency Control). The <strong>dead tuples</strong> are later cleaned up by a <strong>VACUUM</strong> process.</p><p>In the case of a HOT update, the new tuple is written in place in the same physical location in the heap, <strong>without modifying any indexes</strong>. This allows the update to be more efficient than a traditional update, which would require index entries to be updated, potentially leading to more disk I/O.</p><p>Here’s how HOT update works step by step:</p><ol><li><strong>Update Request</strong>: An update is issued to a row, but the update does not modify any indexed columns (or does not change the values in such a way that it would require an index update).<li><strong>Heap Update</strong>: PostgreSQL checks whether the update can be classified as a HOT update. If the update can be performed without needing to update the index, the row is updated directly in the table’s heap.<li><strong>Tuple Versioning</strong>: The old version of the tuple is marked as obsolete but isn’t physically deleted until the next vacuum cycle (due to MVCC). The new version is written in the same location.<li><strong>No Index Update</strong>: Since indexed columns are not modified, no changes are made to the indexes, reducing the overhead of maintaining the index structures.<li><strong>Tuple Visibility</strong>: When querying the table, PostgreSQL ensures that the most recent tuple version (i.e., the new version after the HOT update) is visible to transactions, using its MVCC mechanism.</ol><h3 id="example-of-hot-update"><span class="mr-2">Example of HOT Update</span><a href="#example-of-hot-update" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Let’s take an example with a simple table:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employees</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salary</span> <span class="nb">INT</span>
<span class="p">);</span>

</pre></table></code></div></div><p>And let’s say we have an index on the <code class="language-plaintext highlighter-rouge">salary</code> column:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_salary</span> <span class="k">ON</span> <span class="n">employees</span><span class="p">(</span><span class="n">salary</span><span class="p">);</span>

</pre></table></code></div></div><p>Now, suppose we have a row with <code class="language-plaintext highlighter-rouge">id=1</code>, <code class="language-plaintext highlighter-rouge">name='Alice'</code>, and <code class="language-plaintext highlighter-rouge">salary=50000</code>:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">employees</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">salary</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">50000</span><span class="p">);</span>

</pre></table></code></div></div><p>Now, let’s update this row to change the <code class="language-plaintext highlighter-rouge">name</code>:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">UPDATE</span> <span class="n">employees</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Alicia'</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

</pre></table></code></div></div><p>In this case, the update only modifies the <code class="language-plaintext highlighter-rouge">name</code> column, which is <strong>not indexed</strong>, so PostgreSQL will perform a <strong>HOT update</strong>:</p><ol><li><strong>Heap update</strong>: The new <code class="language-plaintext highlighter-rouge">name</code> (‘Alicia’) is written in the same heap tuple location.<li><strong>No index update</strong>: The <code class="language-plaintext highlighter-rouge">salary</code> column, which is part of the index, is not modified, so the index on <code class="language-plaintext highlighter-rouge">salary</code> is <strong>not updated</strong>.<li>The old tuple (with <code class="language-plaintext highlighter-rouge">name='Alice'</code>) is marked as <strong>dead</strong> but not removed immediately.<li>The index on <code class="language-plaintext highlighter-rouge">salary</code> remains unchanged.</ol><h3 id="when-hot-updates-are-not-possible"><span class="mr-2">When HOT Updates Are Not Possible</span><a href="#when-hot-updates-are-not-possible" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HOT updates are not possible when:</p><ol><li><p><strong>Indexed columns are modified</strong>: If any column that is part of an index is updated, the index will need to be updated, and the update cannot be a HOT update. In such cases, PostgreSQL has to update the index, which incurs more overhead.</p><p>For example:</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="k">UPDATE</span> <span class="n">employees</span> <span class="k">SET</span> <span class="n">salary</span> <span class="o">=</span> <span class="mi">55000</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
</pre></table></code></div></div><p>Here, the <code class="language-plaintext highlighter-rouge">salary</code> column is indexed, so the index on <code class="language-plaintext highlighter-rouge">salary</code> must be updated, and a HOT update cannot be used.</p><li><strong>Row is moved</strong>: If the update changes the physical location of the row (e.g., due to the row becoming too large), a new version of the tuple will be written in a different location in the heap. This will require index updates to reflect the new location of the tuple.<li><strong>The table is not well-suited for HOT updates</strong>: If a table is heavily indexed, HOT updates will be less common because even minor changes may require updating the indexes.</ol><h3 id="performance-impact-of-hot-updates"><span class="mr-2">Performance Impact of HOT Updates</span><a href="#performance-impact-of-hot-updates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HOT updates can significantly improve <strong>write performance</strong> because they reduce the need for index maintenance during updates. This means that:</p><ul><li><strong>Fewer I/O operations</strong>: There is less disk I/O because the index does not need to be updated.<li><strong>Faster update times</strong>: Since the index does not need to be updated, the overall time to perform an update is faster.<li><strong>Reduced contention</strong>: Since indexes are not modified, there is less contention between different transactions trying to modify the same index.</ul><p>However, there are some trade-offs:</p><ul><li><strong>Vacuum overhead</strong>: Dead tuples accumulate faster because updates are done in place without cleaning up old rows immediately. This means the vacuum process has to work harder to clean up old tuples that are no longer visible.<li><strong>Hotspotting</strong>: If rows are frequently updated, the same tuple may be rewritten in place multiple times, leading to potential <strong>tuple chaining</strong> or <strong>index bloat</strong> (especially if there are more complex updates later on).</ul><h3 id="example-of-performance-impact"><span class="mr-2">Example of Performance Impact</span><a href="#example-of-performance-impact" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Consider the following two scenarios:</p><ol><li><strong>Without HOT Update (Traditional Update)</strong>:<ul><li>You have an index on <code class="language-plaintext highlighter-rouge">salary</code>.<li>Every time the <code class="language-plaintext highlighter-rouge">salary</code> column is updated, PostgreSQL needs to:<ul><li>Write the new version of the row.<li>Update the index on <code class="language-plaintext highlighter-rouge">salary</code> to point to the new location of the row.</ul></ul><li><strong>With HOT Update</strong>:<ul><li>You update the <code class="language-plaintext highlighter-rouge">name</code> column (which is not indexed).<li>PostgreSQL can update the row in place without modifying the <code class="language-plaintext highlighter-rouge">salary</code> index, reducing I/O.</ul></ol><p>If you update <code class="language-plaintext highlighter-rouge">name</code> frequently, PostgreSQL will only have to update the heap and not the index, which results in <strong>significant performance improvements</strong> in cases of high update traffic.</p><h3 id="conclusion-1"><span class="mr-2">Conclusion</span><a href="#conclusion-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HOT updates are a performance optimization in PostgreSQL that allows for faster row updates by avoiding unnecessary index modifications. When certain conditions are met (such as not modifying indexed columns), PostgreSQL will update the row directly in the heap, reducing the overhead of maintaining indexes. This results in better performance, particularly in write-heavy applications, but comes with trade-offs like increased need for vacuuming to clean up dead tuples.</p><h2 id="how-to-choose-the-order-of-columns-to-create-a-composite-index"><span class="mr-2"><strong>How to choose the order of columns to create a composite index?</strong></span><a href="#how-to-choose-the-order-of-columns-to-create-a-composite-index" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><p>If I have a query that does a filter on say 10 columns (joined by AND), is it advisable to have a composite index on all 10 columns? Let’s assume for simplicity that this is the only query for this table</p><li><p>Is the Query Planner smart enough to arrange the filter in an order that will be a subset of the composite index? For example if I have a composite index on a,b, c and d columns. I hit a query saying <code class="language-plaintext highlighter-rouge">select a,b,c,d where c=10 and a=20 and b=30</code>; Will the Query Planner use the composite index?</p><li><p>Is there good practice for the order in which the column order for composite indexes be chosen?</p></ol><p><strong>Answer:</strong> 1) you see think about how a composite index works, It includes all values of indexed columns in the b-tree structure. This increases the size of the index which leads to more IOs to read. This of course depends on the data types of what you are indexing. Another side effect is updates to any of those columns Would require updating the index, this is not necessary slow but just increases IO.</p><p>I would be pragmatic and find out the frequency of values in each column and only index the column that would give me maximum benefit, this requires you understanding the data model, the nature of the data stored and the correlation between them.</p><p>2) yes, the planner will do what’s necessary the order of the where clause doesn’t matter as long as everything is an AND.</p><p>3) depends on your where clause and the minimum set of the query.</p><h2 id="redis-durability-vs-persistence"><span class="mr-2"><strong>Redis “Durability” vs “Persistence”</strong></span><a href="#redis-durability-vs-persistence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>You said that Redis doesn’t offer Durability because of course it is memory database “lives in RAM” if electricity goes down, data is lost. And also yo said but it has Persistence. I need to know what do you mean by that and i want to understand from your point of view. What is Durability vs Persistence?</p><p>Thanks in advance and thank you so much for this amazing lecture, i loved it so much and i installed Postgres on my RaspberryPi and went with all examples and applied them all and took 160 lines of notes and steps :D</p><p><strong>Answer:</strong> Persistence is the ability and feature that a database provide to persist and store data on disk.</p><p>Durability is when you successfully write a value to the DB it should always persist to disk so it is available when the DB crashes/restarts.</p><p>Redis is an in memory database that supports persistence but they do offer true durability.</p><p>Redis persist data in an asynchronous snapshot every x seconds. So you can write a value in memory but if the power goes off before it gets persisted to snapshot, you lost it..</p><p>I believe this might have changed in the recent versions of redis. Subtle difference but important to point out.</p><p>Redis uses AOF (Append Only File) and hence supports high durability at high throughput. It also allows controlling the knob (Snapshot vs AOF)</p><h2 id="reference-to-related-articles"><span class="mr-2">Reference to related articles</span><a href="#reference-to-related-articles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="postgres-vs-msysql"><strong>Postgres vs MySQL (The fundamental differences)</strong></a><li><a href="postgresql-process-architecture"><strong>PostgreSQL Process Architecture</strong></a><li><a href="wal-redo-and-undo-logs-in-postgres"><strong>WAL, Redo and undo logs in postgres</strong></a><li><a href="how-shopify-engineering-improved-database-writes"><strong>How Shopify’s engineering improved database writes by 50% with ULID</strong></a><li><a href="postgres-locks-a-deep-dive"><strong>Postgres Locks — A Deep Dive</strong></a><li><a href="how-slow-is-select-in-row-store"><strong>How Slow is select * in row store?</strong></a><li><a href="why-uber-engineering-switched-from-postgres-to-mysql"><strong>Why Uber Engineering Switched from Postgres to MySQL</strong></a><li><a href="/assets/document/attachment/database-engineering-fundamental-part-5//NULL.pdf"><strong>NULL.pdf</strong></a><li><a href="write-amplification-problem-in-postgresql"><strong>Write Amplification Problem in PostgreSQL</strong></a><li><a href="toast-table-in-postgres"><strong>TOAST table in Postgres</strong></a><li><a href="innodb-b-tree-latch-optimization-history"><strong>InnoDB B-tree Latch Optimization History</strong></a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/article/'>Article</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/softwareengineering/" class="post-tag no-text-decoration" >softwareengineering</a> <a href="/tags/backenddevelopment/" class="post-tag no-text-decoration" >backenddevelopment</a> <a href="/tags/database-engineering/" class="post-tag no-text-decoration" >database-engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Part+5%3A+Database+Engineering+Fundamentals+-+Pravin+on+Software&url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Part+5%3A+Database+Engineering+Fundamentals+-+Pravin+on+Software&u=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2F&text=Part+5%3A+Database+Engineering+Fundamentals+-+Pravin+on+Software" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/database-engineering-fundamental-part-2/">Part 2: Database Engineering Fundamentals</a><li><a href="/posts/system-design-roadmap/">Comprehensive Roadmap for Low-Level and High-Level Design Interview Preparation</a><li><a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/">Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</a><li><a href="/database-engineering-fundamental-part-1/">Part 1: Database Engineering Fundamentals</a><li><a href="/database-engineering-fundamental-part-1/database-page/">Part 1: Database Engineering Fundamentals: Database Page</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/"><div class="card-body"> <em class="small" data-ts="1720157400" data-df="ll" > Jul 5, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</h3><div class="text-muted small"><p> Write Amplification Problem in PostgreSQL Write Amplification Problem in PostgreSQL The Write Amplification Problem (WAP) typically arises in systems using Solid State Drives (SSDs) or other stor...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/"><div class="card-body"> <em class="small" data-ts="1719775800" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals</h3><div class="text-muted small"><p> Table of Contents ACID Properties Understanding Database Internals Row-Based vs Column-Based Databases Primary Key vs Secondary Key Database Indexing SQL Query Planner and Optimizer ...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/database-page/"><div class="card-body"> <em class="small" data-ts="1719779400" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals: Database Page</h3><div class="text-muted small"><p> Databases Pages (Article) Database Pages — A deep dive Databases often use fixed-size pages to store data. Tables, collections, rows, columns, indexes, sequences, documents and more eventually en...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/database-engineering-fundamental-part-4/" class="btn btn-outline-primary" prompt="Older"><p>Part 4: Database Engineering Fundamentals</p></a> <a href="/database-engineering-fundamental-part-5/how-shopify-engineering-improved-database-writes/" class="btn btn-outline-primary" prompt="Newer"><p>Part 5: Database Engineering Fundamentals: How Shopify’s engineering improved database writes?</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://pravin.dev/database-engineering-fundamental-part-5/'; this.page.identifier = '/database-engineering-fundamental-part-5/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://pravin-dev.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WP90FFJ6SJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WP90FFJ6SJ'); }); </script>
