<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL" /><meta name="author" content="Pravin Tripathi" /><meta property="og:locale" content="en" /><meta name="description" content="Why Uber Engineering Switched from Postgres to MySQL" /><meta property="og:description" content="Why Uber Engineering Switched from Postgres to MySQL" /><link rel="canonical" href="https://pravin.dev/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/" /><meta property="og:url" content="https://pravin.dev/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/" /><meta property="og:site_name" content="Pravin on Software" /><meta property="og:image" content="https://pravin.dev/header.png" /><meta property="og:image:height" content="900" /><meta property="og:image:width" content="1600" /><meta property="og:image:alt" content="Generated using Copilot" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-05T10:00:00+05:30" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://pravin.dev/header.png" /><meta name="twitter:image:alt" content="Generated using Copilot" /><meta property="twitter:title" content="Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL" /><meta name="twitter:site" content="@pravin_yo" /><meta name="twitter:creator" content="@pravin_yo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pravin Tripathi","url":"https://www.linkedin.com/in/pravin-r-tripathi"},"dateModified":"2025-03-22T16:02:56+05:30","datePublished":"2024-07-05T10:00:00+05:30","description":"Why Uber Engineering Switched from Postgres to MySQL","headline":"Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL","image":{"width":1600,"height":900,"alt":"Generated using Copilot","url":"https://pravin.dev/header.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pravin.dev/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/"},"url":"https://pravin.dev/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/"}</script><title>Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL | Pravin on Software</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Pravin on Software"><meta name="application-name" content="Pravin on Software"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Pravin on Software</a></div><div class="site-subtitle font-italic">My Learning and Experiments in Software Engineering</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/pravinyo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/pravin_yo" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['pravinyo12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Part 5: Database Engineering Fundamentals: Why Uber Engineering Switched from Postgres to MySQL</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1720153800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 5, 2024 </em> </span> <span> Updated <em class="" data-ts="1742639576" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 22, 2025 </em> </span><div class="mt-3 mb-3"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 900'%3E%3C/svg%3E" data-src="/assets/img/database-engineering-fundamental-part-5/header.png" class="preview-img bg" alt="Generated using Copilot" width="1600" height="900" data-proofer-ignore><figcaption class="pt-2 pb-2">Generated using Copilot</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5176 words"> <em>28 min</em> read</span></div></div></div><div class="post-content"><h1 id="why-uber-engineering-switched-from-postgres-to-mysql">Why Uber Engineering Switched from Postgres to MySQL</h1><h3 id="26-july-2016global"><span class="mr-2">26 July 2016 / Global</span><a href="#26-july-2016global" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://blog.uber-cdn.com/cdn-cgi/image/width=2160,quality=80,onerror=redirect,format=/assets/img/database-engineering-fundamental-part-5/auto/wp-content/uploads/2016/07/MySQL_Index_Property_Header.png" alt="" data-proofer-ignore></p><h1 id="introduction"><strong>Introduction</strong></h1><p>The early architecture of Uber consisted of a monolithic backend application written in Python that used <a href="http://www.postgresql.org/">Postgres</a> for data persistence. Since that time, the architecture of Uber has changed significantly, to a model of <a href="https://www.uber.com/blog/soa/">microservices</a> and new data platforms. Specifically, in many of the cases where we previously used Postgres, we now use <a href="https://www.uber.com/blog/schemaless-part-one/">Schemaless</a>, a novel database sharding layer built on top of MySQL. In this article, we’ll explore some of the drawbacks we found with Postgres and explain the decision to build Schemaless and other backend services on top of MySQL.</p><h1 id="the-architecture-of-postgres"><strong>The Architecture of Postgres</strong></h1><p>We encountered many Postgres limitations:</p><ul><li>Inefficient architecture for writes<li>Inefficient data replication<li>Issues with table corruption<li>Poor replica MVCC support<li>Difficulty upgrading to newer releases</ul><p>We’ll look at all of these limitations through an analysis of Postgres’s representation of table and index data on disk, especially when compared to the way MySQL represents the same data with its <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">InnoDB storage engine</a>. Note that the analysis that we present here is primarily based on our experience with the somewhat old Postgres 9.2 release series. To our knowledge, the internal architecture that we discuss in this article has not changed significantly in newer Postgres releases, and the basic design of the on-disk representation in 9.2 hasn’t changed significantly since at least the Postgres 8.3 release (now nearly 10 years old).</p><p><strong>On-Disk Format</strong></p><p>A relational database must perform a few key tasks:</p><ul><li>Provide insert/update/delete capabilities<li>Provide capabilities for making schema changes<li>Implement a <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">multiversion concurrency control</a> (MVCC) mechanism so that different connections have a transactional view of the data they work with</ul><p>Considering how all of these features will work together is an essential part of designing how a database represents data on disk.</p><p>One of the core design aspects of Postgres is immutable row data. These immutable rows are called “tuples” in Postgres parlance. These tuples are uniquely identified by what Postgres calls a <a href="http://www.postgresql.org/docs/9.5/static/ddl-system-columns.html">ctid</a>. A ctid conceptually represents the on-disk location (i.e., physical disk offset) for a tuple. Multiple ctids can potentially describe a single row (e.g., when multiple versions of the row exist for MVCC purposes, or when old versions of a row have not yet been reclaimed by the <a href="http://www.postgresql.org/docs/9.2/static/routine-vacuuming.html#AUTOVACUUM">autovacuum</a> process). A collection of organized tuples form a table. Tables themselves have indexes, which are organized as data structures (typically B-trees) that map index fields to a ctid payload.</p><p>Typically, these ctids are transparent to users, but knowing how they work helps you understand the on-disk structure of Postgres tables. To see the current ctid for a row, you can add “ctid” to the column list in a WHERE clause:</p><p>`uber@[local] uber=&gt; SELECT ctid, * FROM my_table LIMIT 1;</p><p>-[ RECORD 1 ]——–+——————————</p><div class="table-wrapper"><table><tbody><tr><td>ctid                 <td>(0,1)</table></div><p>…other fields here…`</p><p>To explain the details of the layout, let’s consider an example of a simple users table. For each user, we have an auto-incrementing user ID primary key, the user’s first and last name, and the user’s birth year. We also define a compound secondary index on the user’s full name (first and last name) and another secondary index on the user’s birth year. The <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL</a> to create such a table might be like this:</p><p>`CREATE TABLE users (</p><p>   id SERIAL,</p><p>   first TEXT,</p><p>   last TEXT,</p><p>   birth_year INTEGER,</p><p>   PRIMARY KEY (id)</p><p>); CREATE INDEX ix_users_first_last ON users (first, last); CREATE INDEX ix_users_birth_year ON users (birth_year);`</p><hr /><p>Note the three indexes in this definition: the primary key index plus the two secondary indexes we defined.</p><p>For the examples in this article we’ll start with the following data in our table, which consists of a selection of influential historical mathematicians:</p><div class="table-wrapper"><table><thead><tr><th><strong>id</strong><th><strong>first</strong><th><strong>last</strong><th><strong>birth_year</strong><tbody><tr><td>1<td><a href="https://en.wikipedia.org/wiki/Blaise_Pascal">Blaise</a><td><a href="https://en.wikipedia.org/wiki/Blaise_Pascal">Pascal</a><td>1623<tr><td>2<td><a href="https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz">Gottfried</a><td><a href="https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz">Leibniz</a><td>1646<tr><td>3<td><a href="https://en.wikipedia.org/wiki/Emmy_Noether">Emmy</a><td><a href="https://en.wikipedia.org/wiki/Emmy_Noether">Noether</a><td>1882<tr><td>4<td><a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Muhammad</a><td><a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">al-Khwārizmī</a><td>780<tr><td>5<td><a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan</a><td><a href="https://en.wikipedia.org/wiki/Alan_Turing">Turing</a><td>1912<tr><td>6<td><a href="https://en.wikipedia.org/wiki/Srinivasa_Ramanujan">Srinivasa</a><td><a href="https://en.wikipedia.org/wiki/Srinivasa_Ramanujan">Ramanujan</a><td>1887<tr><td>7<td><a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Ada</a><td><a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Lovelace</a><td>1815<tr><td>8<td><a href="https://en.wikipedia.org/wiki/Henri_Poincar%C3%A9">Henri</a><td><a href="https://en.wikipedia.org/wiki/Henri_Poincar%C3%A9">Poincaré</a><td>1854</table></div><p>As described earlier, each of these rows implicitly has a unique, opaque ctid. Therefore, we can think of the internal representation of the table like this:</p><div class="table-wrapper"><table><thead><tr><th><strong>ctid</strong><th><strong>id</strong><th><strong>first</strong><th><strong>last</strong><th><strong>birth_year</strong><tbody><tr><td>A<td>1<td>Blaise<td>Pascal<td>1623<tr><td>B<td>2<td>Gottfried<td>Leibniz<td>1646<tr><td>C<td>3<td>Emmy<td>Noether<td>1882<tr><td>D<td>4<td>Muhammad<td>al-Khwārizmī<td>780<tr><td>E<td>5<td>Alan<td>Turing<td>1912<tr><td>F<td>6<td>Srinivasa<td>Ramanujan<td>1887<tr><td>G<td>7<td>Ada<td>Lovelace<td>1815<tr><td>H<td>8<td>Henri<td>Poincaré<td>1854</table></div><p>The primary key index, which maps ids to ctids, is defined like this:</p><div class="table-wrapper"><table><thead><tr><th><strong>id</strong><th><strong>ctid</strong><tbody><tr><td>1<td>A<tr><td>2<td>B<tr><td>3<td>C<tr><td>4<td>D<tr><td>5<td>E<tr><td>6<td>F<tr><td>7<td>G<tr><td>8<td>H</table></div><p>The B-tree is defined on the id field, and each node in the B-tree holds the ctid value. Note that in this case, the order of the fields in the B-tree happens to be the same as the order in the table due to the use of an auto-incrementing id, but this doesn’t necessarily need to be the case.</p><p>The secondary indexes look similar; the main difference is that the fields are stored in a different order, as the B-tree must be organized lexicographically. The (first, last) index starts with first names toward the top of the alphabet:</p><div class="table-wrapper"><table><thead><tr><th><strong>first</strong><th><strong>last</strong><th><strong>ctid</strong><tbody><tr><td>Ada<td>Lovelace<td>G<tr><td>Alan<td>Turing<td>E<tr><td>Blaise<td>Pascal<td>A<tr><td>Emmy<td>Noether<td>C<tr><td>Gottfried<td>Leibniz<td>B<tr><td>Henri<td>Poincaré<td>H<tr><td>Muhammad<td>al-Khwārizmī<td>D<tr><td>Srinivasa<td>Ramanujan<td>F</table></div><p>Likewise, the birth_year index is clustered in ascending order, like this:</p><div class="table-wrapper"><table><thead><tr><th><strong>birth_year</strong><th><strong>ctid</strong><tbody><tr><td>780<td>D<tr><td>1623<td>A<tr><td>1646<td>B<tr><td>1815<td>G<tr><td>1854<td>H<tr><td>1887<td>F<tr><td>1882<td>C<tr><td>1912<td>E</table></div><p>As you can see, in both of these cases the ctid field in the respective secondary index is not increasing lexicographically, unlike in the case of an auto-incrementing primary key.</p><p>Suppose we need to update a record in this table. For instance, let’s say we’re updating the birth year field for another estimate of al-Khwārizmī’s year of birth, 770 CE. As we mentioned earlier, row tuples are immutable. Therefore, to update the record, we add a new tuple to the table. This new tuple has a new opaque ctid, which we’ll call <em>I</em> . Postgres needs to be able to distinguish the new, active tuple at <em>I</em> from the old tuple at <em>D</em>. Internally, Postgres stores within each tuple a version field and pointer to the previous tuple (if there is one). Accordingly, the new structure of the table looks like this:</p><div class="table-wrapper"><table><thead><tr><th><strong>ctid</strong><th><strong>prev</strong><th><strong>id</strong><th><strong>first</strong><th><strong>last</strong><th><strong>birth_year</strong><tbody><tr><td>A<td>null<td>1<td>Blaise<td>Pascal<td>1623<tr><td>B<td>null<td>2<td>Gottfried<td>Leibniz<td>1646<tr><td>C<td>null<td>3<td>Emmy<td>Noether<td>1882<tr><td>D<td>null<td>4<td>Muhammad<td>al-Khwārizmī<td>780<tr><td>E<td>null<td>5<td>Alan<td>Turing<td>1912<tr><td>F<td>null<td>6<td>Srinivasa<td>Ramanujan<td>1887<tr><td>G<td>null<td>7<td>Ada<td>Lovelace<td>1815<tr><td>H<td>null<td>8<td>Henri<td>Poincaré<td>1854<tr><td>I<td>D<td>4<td>Muhammad<td>al-Khwārizmī<td>770</table></div><p>As long as two versions of the al-Khwārizmī row exist, the indexes must hold entries for both rows. For brevity, we omit the primary key index and show only the secondary indexes here, which look like this:</p><div class="table-wrapper"><table><thead><tr><th><strong>first</strong><th><strong>last</strong><th><strong>ctid</strong><tbody><tr><td>Ada<td>Lovelace<td>G<tr><td>Alan<td>Turing<td>E<tr><td>Blaise<td>Pascal<td>A<tr><td>Emmy<td>Noether<td>C<tr><td>Gottfried<td>Leibniz<td>B<tr><td>Henri<td>Poincaré<td>H<tr><td>Muhammad<td>al-Khwārizmī<td>D<tr><td>Muhammad<td>al-Khwārizmī<td>I<tr><td>Srinivasa<td>Ramanujan<td>F</table></div><div class="table-wrapper"><table><thead><tr><th><strong>birth_year</strong><th><strong>ctid</strong><tbody><tr><td>770<td>I<tr><td>780<td>D<tr><td>1623<td>A<tr><td>1646<td>B<tr><td>1815<td>G<tr><td>1854<td>H<tr><td>1887<td>F<tr><td>1882<td>C<tr><td>1912<td>E</table></div><p>We’ve represented the old version in red and the new row version in green. Under the hood, Postgres uses <em>another</em> field holding the row version to determine which tuple is most recent. This added field lets the database determine which row tuple to serve to a transaction that may not be allowed to see the latest row version.</p><p><img data-src="https://blog.uber-cdn.com/cdn-cgi/image/width=1024,quality=80,onerror=redirect,format=/assets/img/database-engineering-fundamental-part-5/auto/wp-content/uploads/2016/07/Postgres_Tuple_Property_.png" alt="" data-proofer-ignore></p><p>With Postgres, the primary index and secondary indexes all point directly to the on-disk tuple offsets. When a tuple location changes, all indexes must be updated.</p><p><strong>Replication</strong></p><p>When we insert a new row into a table, Postgres needs to replicate it if streaming replication is enabled. For crash recovery purposes, the database already maintains a <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead log</a> (WAL) and uses it to implement <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit</a>. The database must maintain this WAL even when streaming replication is not enabled because the WAL allows the atomicity and durability aspects of <a href="https://en.wikipedia.org/wiki/ACID">ACID</a>.</p><p>We can understand the WAL by considering what happens if the database crashes unexpectedly, like during a sudden power loss. The WAL represents a ledger of the changes the database plans to make to the on-disk contents of tables and indexes. When the Postgres daemon first starts up, the process compares the data in this ledger with the actual data on disk. If the ledger contains data that isn’t reflected on disk, the database corrects any tuple or index data to reflect the data indicated by the WAL. It then rolls back any data that appears in the WAL but is from a partially applied transaction (meaning that the transaction was never committed).</p><p>Postgres implements streaming replication by sending the WAL on the master database to replicas. Each replica database effectively acts as if it’s in crash recovery, constantly applying WAL updates just as it would if it were starting up after a crash. The only difference between streaming replication and actual crash recovery is that replicas in “hot standby” mode serve read queries while applying the streaming WAL, whereas a Postgres database that’s actually in crash recovery mode typically refuses to serve any queries until the database instance finishes the crash recovery process.</p><p>Because the WAL is actually designed for crash recovery purposes, it contains low-level information about the on-disk updates. The content of the WAL is at the level of the actual on-disk representation of row tuples and their disk offsets (i.e., the row ctids). If you pause a Postgres master and replica when the replica is fully caught up, the actual on-disk content on the replica exactly matches what’s on the master byte for byte. Therefore, tools like <a href="https://en.wikipedia.org/wiki/Rsync">rsync</a> can fix a corrupted replica if it gets out of date with the master.</p><p><strong>Consequences of Postgres’s Design</strong></p><p>Postgres’s design resulted in inefficiencies and difficulties for our <a href="https://www.uber.com/blog/category/uberdata/">data at Uber</a>.</p><p><strong>Write Amplification</strong></p><p>The first problem with Postgres’s design is known in other contexts as <a href="https://en.wikipedia.org/wiki/Write_amplification">write amplification</a>. Typically, write amplification refers to a problem with writing data to SSD disks: a small logical update (say, writing a few bytes) becomes a much larger, costlier update when translated to the physical layer. The same issue arises in Postgres. In our previous example when we made the small logical update to the birth year for al-Khwārizmī, we had to issue at least four physical updates:</p><ol><li>Write the new row tuple to the <a href="https://en.wikipedia.org/wiki/Tablespace">tablespace</a><li>Update the primary key index to add a record for the new tuple<li>Update the (first, last) index to add a record for the new tuple<li><p>Update the birth_year index to add a record for the new tuple</p><li><ol><li>Write the new row tuple to the <a href="https://en.wikipedia.org/wiki/Tablespace">tablespace</a></ol><li><ol><li>Update the primary key index to add a record for the new tuple</ol><li><ol><li>Update the (first, last) index to add a record for the new tuple</ol><li><ol><li>Update the birth_year index to add a record for the new tuple</ol></ol><p>In fact, these four updates only reflect the writes made to the main tablespace; each of these writes needs to be reflected in the WAL as well, so the total number of writes on disk is even larger.</p><p>What’s noteworthy here are updates 2 and 3. When we updated the birth year for al-Khwārizmī, we didn’t actually change his primary key, nor did we change his first and last name. However, these indexes still must be updated with the creation of a new row tuple in the database for the row record. For tables with a large number of secondary indexes, these superfluous steps can cause enormous inefficiencies. For instance, if we have a table with a dozen indexes defined on it, an update to a field that is only covered by a single index must be propagated into all 12 indexes to reflect the ctid for the new row.</p><p><strong>Replication</strong></p><p>This write amplification issue naturally translates into the replication layer as well because replication occurs at the level of on-disk changes. Instead of replicating a small logical record, such as “Change the birth year for ctid <em>D</em> to now be 770,” the database instead writes out WAL entries for all four of the writes we just described, and all four of these WAL entries propagate over the network. Thus, the write amplification problem also translates into a replication amplification problem, and the Postgres replication data stream quickly becomes extremely verbose, potentially occupying a large amount of bandwidth.</p><p>In cases where Postgres replication happens purely within a single data center, the replication bandwidth may not be a problem. Modern networking equipment and switches can handle a large amount of bandwidth, and many hosting providers offer free or cheap intra–data center bandwidth. However, when replication must happen between data centers, issues can quickly escalate. For instance, Uber originally used physical servers in a colocation space on the West Coast. For disaster recovery purposes, we added servers in a second East Coast colocation space. In this design we had a master Postgres instance (plus replicas) in our western data center and a set of replicas in the eastern one.</p><p><a href="http://www.postgresql.org/docs/9.2/static/warm-standby.html">Cascading replication</a> limits the inter–data center bandwidth requirements to the amount of replication required between just the master and a single replica, even if there are many replicas in the second data center. However, the verbosity of the Postgres replication protocol can still cause an overwhelming amount of data for a database that uses a lot of indexes. Purchasing very high bandwidth cross-country links is expensive, and even in cases where money is not an issue it’s simply not possible to get a cross-country networking link with the same bandwidth as a local interconnect. This bandwidth problem also caused issues for us with WAL archival. In addition to sending all of the WAL updates from West Coast to East Coast, we archived all WALs to a file storage web service, both for extra assurance that we could restore data in the event of a disaster and so that archived WALs could bring up new replicas from database snapshots. During peak traffic early on, our bandwidth to the storage web service simply wasn’t fast enough to keep up with the rate at which WALs were being written to it.</p><p><strong>Data Corruption</strong></p><p>During a routine master database promotion to increase database capacity, we ran into a Postgres 9.2 bug. Replicas followed <a href="http://www.postgresql.org/docs/9.2/static/continuous-archiving.html">timeline switches</a> <a href="http://www.postgresql.org/docs/9.2/static/continuous-archiving.html">incorrectly</a>, causing some of them to misapply some WAL records. Because of this bug, some records that should have been marked as inactive by the versioning mechanism weren’t actually marked inactive.</p><p>The following query illustrates how this bug would affect our users table example:</p><p>SELECT * FROM users WHERE id = 4;</p><p>This query would return two records: the original al-Khwārizmī row with the 780 CE birth year, plus the new al-Khwārizmī row with the 770 CE birth year. If we were to add ctid to the WHERE list, we would see different ctid values for the two returned records, as one would expect for two distinct row tuples.</p><p>This problem was extremely vexing for a few reasons. To start, we couldn’t easily tell how many rows this problem affected. The duplicated results returned from the database caused application logic to fail in a number of cases. We ended up adding defensive programming statements to detect the situation for tables known to have this problem. Because the bug affected all of the servers, the corrupted rows were different on different replica instances, meaning that on one replica row <em>X</em> might be bad and row <em>Y</em> would be good, but on another replica row <em>X</em> might be good and row <em>Y</em> might be bad. In fact, we were unsure about the number of replicas with corrupted data and about whether the problem had affected the master.</p><p>From what we could tell, the problem only manifested on a few rows per database, but we were extremely worried that, because replication happens at the physical level, we could end up completely corrupting our database indexes. An essential aspect of B-trees are that they must be periodically <a href="https://en.wikipedia.org/wiki/B-tree#Rebalancing_after_deletion">rebalanced</a>, and these rebalancing operations can completely change the structure of the tree as sub-trees are moved to new on-disk locations. If the wrong data is moved, this can cause large parts of the tree to become completely invalid.</p><p>In the end, we were able to track down the actual bug and use it to determine that the newly promoted master did not have any corrupted rows. We fixed the corruption issue on the replicas by resyncing all of them from a new snapshot of the master, a laborious process; we only had enough capacity to take a few replicas out of the load balancing pool at a time.</p><p>The bug we ran into only affected certain releases of Postgres 9.2 and has been fixed for a long time now. However, we still find it worrisome that this class of bug can happen at all. A new version of Postgres could be released at any time that has a bug of this nature, and because of the way replication works, this issue has the potential to spread into all of the databases in a replication hierarchy.</p><p><strong>Replica MVCC</strong></p><p>Postgres does not have true replica MVCC support. The fact that replicas apply WAL updates <a href="http://blog.2ndquadrant.com/tradeoffs_in_hot_standby_deplo/">results in them having a copy of on-disk data identical to the master</a> at any given point in time. This design poses a problem for Uber.</p><p>Postgres needs to maintain a copy of old row versions for MVCC. If a streaming replica has an open transaction, updates to the database are blocked if they affect rows held open by the transaction. In this situation, Postgres pauses the WAL application thread until the transaction has ended. This is problematic if the transaction takes a long amount of time, since the replica can severely lag behind the master. Therefore, Postgres applies a timeout in such situations: if a transaction blocks the WAL application for a <a href="https://www.postgresql.org/docs/9.2/static/hot-standby.html#HOT-STANDBY-CONFLICT">set amount of time</a>, Postgres kills that transaction.</p><p>This design means that replicas can routinely lag seconds behind master, and therefore it is easy to write code that results in killed transactions. This problem might not be apparent to application developers writing code that obscures where transactions start and end. For instance, say a developer has some code that has to email a receipt to a user. Depending on how it’s written, the code may implicitly have a database transaction that’s held open until after the email finishes sending. While it’s always bad form to let your code hold open database transactions while performing unrelated blocking I/O, the reality is that most engineers are not database experts and may not always understand this problem, especially when using an ORM that obscures low-level details like open transactions.</p><p><strong>Postgres Upgrades</strong></p><p>Because replication records work at the physical level, it’s not possible to replicate data between different general availability releases of Postgres. A master database running Postgres 9.3 cannot replicate to a replica running Postgres 9.2, nor can a master running 9.2 replicate to a replica running Postgres 9.3.</p><p>We followed <a href="https://www.postgresql.org/docs/current/static/pgupgrade.html">these steps</a> to upgrade from one Postgres GA release to another:</p><ul><li>Shut down the master database.<li>Run a command called pg_upgrade on the master, which updates the master data in place. This can easily take many hours for a large database, and no traffic can be served from the master while this process takes place.<li>Start the master again.<li>Create a new snapshot of the master. This step completely copies all data from the master, so it also takes many hours for a large database.<li>Wipe each replica and restore the new snapshot from the master to the replica.<li>Bring each replica back into the replication hierarchy. Wait for the replica to fully catch up to all updates applied by the master while the replica was being restored.</ul><p>We started out with Postgres 9.1 and successfully completed the upgrade process to move to Postgres 9.2. However, the process took so many hours that we couldn’t afford to do the process again. By the time Postgres 9.3 came out, Uber’s growth increased our dataset substantially, so the upgrade would have been even lengthier. For this reason, our legacy Postgres instances run Postgres 9.2 to this day, even though the current Postgres GA release is 9.5.</p><p>If you are running Postgres 9.4 or later, you could use something like <a href="http://2ndquadrant.com/en/resources/pglogical/">pglogical</a>, which implements a logical replication layer for Postgres. Using pglogical, you can replicate data among different Postgres releases, meaning that it’s possible to do an upgrade such as 9.4 to 9.5 without incurring significant downtime. This capability is still problematic because it’s not integrated into the Postgres mainline tree, and pglogical is still not an option for people running on older Postgres releases.</p><h1 id="the-architecture-of-mysql"><strong>The Architecture of MySQL</strong></h1><p>In addition to explaining some of Postgres’s limitations, we also explain why MySQL is an important tool for newer Uber Engineering storage projects, such as Schemaless. In many cases, we found MySQL more favorable for our uses. To understand the differences, we examine MySQL’s architecture and how it contrasts with that of Postgres. We specifically analyze how MySQL works with the <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">InnoDB storage engine</a>. Not only do we use InnoDB at Uber; it’s perhaps the most popular MySQL storage engine.</p><p><strong>InnoDB On-Disk Representation</strong></p><p>Like Postgres, InnoDB supports advanced features like MVCC and mutable data. An exhaustive discussion of InnoDB’s on-disk format is outside the scope of this article; instead, we’ll focus on its core differences from Postgres.</p><p>The most important architectural difference is that while Postgres directly maps index records to on-disk locations, InnoDB maintains a secondary structure. Instead of holding a pointer to the on-disk row location (like the ctid does in Postgres), InnoDB secondary index records hold a pointer to the primary key value. Thus, a secondary index in MySQL associates index keys with primary keys:</p><div class="table-wrapper"><table><thead><tr><th><strong>first</strong><th><strong>last</strong><th><strong>id (primary key)</strong><tbody><tr><td>Ada<td>Lovelace<td>7<tr><td>Alan<td>Turing<td>5<tr><td>Blaise<td>Pascal<td>1<tr><td>Emmy<td>Noether<td>3<tr><td>Gottfried<td>Leibniz<td>2<tr><td>Henri<td>Poincaré<td>8<tr><td>Muhammad<td>al-Khwārizmī<td>4<tr><td>Srinivasa<td>Ramanujan<td>6</table></div><p>In order to perform an index lookup on the (first, last) index, we actually need to do two lookups. The first lookup searches the table and finds the primary key for a record. Once the primary key is found, a second lookup searches the primary key index to find the on-disk location for the row.</p><p>This design means that InnoDB is at a slight disadvantage to Postgres when doing a secondary key lookup, since two indexes must be searched with InnoDB compared to just one for Postgres. However, because the data is normalized, row updates only need to update index records that are actually changed by the row update. Additionally, InnoDB typically does row updates in place. If old transactions need to reference a row for the purposes of MVCC MySQL copies the old row into a special area called the <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html">rollback segment</a>.</p><p>Let’s follow what happens when we update al-Khwārizmī’s birth year. If there is space, the birth year field in the row with id 4 is updated in place (in fact, this update always happens in place, as the birth year is an integer that occupies a fixed amount of space). The birth year index is also updated in place to reflect the new date. The old row data is copied to the rollback segment. The primary key index does not need to be updated, nor does the (first, last) name index. If we have a large number of indexes on this table, we still only have to update the indexes that actually index over the birth_year field. So say we have indexes over fields like signup_date, last_login_time, etc. We don’t need to update these indexes, whereas Postgres would have to.</p><p>This design also makes vacuuming and compaction more efficient. All of the rows that are eligible to be vacuumed are available directly in the rollback segment. By comparison, the Postgres autovacuum process has to do full table scans to identify deleted rows.</p><p><img data-src="https://blog.uber-cdn.com/cdn-cgi/image/width=1024,quality=80,onerror=redirect,format=/assets/img/database-engineering-fundamental-part-5/auto/wp-content/uploads/2016/07/MySQL_Index_Property_.png" alt="" data-proofer-ignore></p><p>MySQL uses an extra layer of indirection: secondary index records point to primary index records, and the primary index itself holds the on-disk row locations. If a row offset changes, only the primary index needs to be updated.</p><p><strong>Replication</strong></p><p>MySQL supports multiple <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-formats.html">different replication modes</a>:</p><ul><li>Statement-based replication replicates logical SQL statements (e.g., it would literally replicate literal statements such as: UPDATE users SET birth_year=770 WHERE id = 4)<li>Row-based replication replicates altered row records<li>Mixed replication mixes these two modes</ul><p>There are various tradeoffs to these modes. Statement-based replication is usually the most compact but can require replicas to apply expensive statements to update small amounts of data. On the other hand, row-based replication, akin to the Postgres WAL replication, is more verbose but results in more predictable and efficient updates on the replicas.</p><p>In MySQL, only the primary index has a pointer to the on-disk offsets of rows. This has an important consequence when it comes to replication. The MySQL replication stream only needs to contain information about logical updates to rows. The replication updates are of the variety “Change the timestamp for row <em>X</em> from <em>T_1</em> to <em>T_2.</em>” Replicas automatically infer any index changes that need to be made as the result of these statements.</p><p>By contrast, the Postgres replication stream contains physical changes, such as “At disk offset 8,382,491, write bytes <em>XYZ</em>.” With Postgres, every physical change made to the disk needs to be included in the WAL stream. Small logical changes (such as updating a timestamp) necessitate many on-disk changes: Postgres must insert the new tuple and update all indexes to point to that tuple. Thus, many changes will be put into the WAL stream. This design difference means that the MySQL replication binary log is significantly more compact than the PostgreSQL WAL stream.</p><p>How each replication stream works also has an important consequence on how MVCC works with replicas. Since the MySQL replication stream has logical updates, replicas can have true MVCC semantics; therefore read queries on replicas won’t block the replication stream. By contrast, the Postgres WAL stream contains physical on-disk changes, so Postgres replicas cannot apply replication updates that conflict with read queries, so they can’t implement MVCC.</p><p>MySQL’s replication architecture means that if bugs do cause table corruption, the problem is unlikely to cause a catastrophic failure. Replication happens at the logical layer, so an operation like rebalancing a <a href="https://en.wikipedia.org/wiki/B-tree">B-tree</a> can never cause an index to become corrupted. A typical MySQL replication issue is the case of a statement being skipped (or, less frequently, applied twice). This may cause data to be missing or invalid, but it won’t cause a database outage.</p><p>Finally, MySQL’s replication architecture makes it trivial to replicate between different MySQL releases. MySQL only increments its version if the replication format changes, which is unusual between various MySQL releases. MySQL’s logical replication format also means that on-disk changes in the storage engine layer do not affect the replication format. The typical way to do a MySQL upgrade is to apply the update to one replica at a time, and once you update all replicas, you promote one of them to become the new master. This can be done with almost zero downtime, and it simplifies keeping MySQL up to date.</p><p><strong>Other MySQL Design Advantages</strong></p><p>So far, we’ve focused on the on-disk architecture for Postgres and MySQL. Some other important aspects of MySQL’s architecture cause it to perform significantly better than Postgres, as well.</p><p><strong>The Buffer Pool</strong></p><p>First, caching works differently in the two databases. Postgres allocates some memory for internal caches, but these caches are typically small compared to the total amount of memory on a machine. To increase performance, Postgres allows the kernel to automatically cache recently accessed disk data via the <a href="https://en.wikipedia.org/wiki/Page_cache">page cache</a>. For instance, our largest Postgres replicas have 768 GB of memory available, but only about 25 GB of that memory is actually <a href="https://en.wikipedia.org/wiki/Resident_set_size">RSS memory</a> faulted in by Postgres processes. This leaves more than 700 GB of memory free to the Linux page cache.</p><p>The problem with this design is that accessing data via the page cache is actually somewhat expensive compared to accessing RSS memory. To look up data from disk, the Postgres process issues <a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a> and <a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> system calls to locate the data. Each of these system calls incurs a context switch, which is more expensive than accessing data from main memory. In fact, Postgres isn’t even fully optimized in this regard: Postgres doesn’t make use of the <a href="http://man7.org/linux/man-pages/man2/pwrite.2.html">pread(2)</a> system call, which coalesces seek + read operations into a single system call.</p><p>By comparison, the InnoDB storage engine implements its own LRU in something it calls the InnoDB <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html">buffer pool</a>. This is logically similar to the Linux page cache but implemented in userspace. While significantly more complicated than Postgres’s design, the InnoDB buffer pool design has some huge upsides:</p><ol><li>It makes it possible to implement a custom LRU design. For instance, it’s possible to detect pathological access patterns that would blow out the LRU and prevent them from doing too much damage.<li><p>It results in fewer context switches. Data accessed via the InnoDB buffer pool doesn’t require any user/kernel context switches. The worst case behavior is the occurrence of a <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB miss</a>, which is relatively cheap and can be minimized by using <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages</a>.</p><li><ol><li>It makes it possible to implement a custom LRU design. For instance, it’s possible to detect pathological access patterns that would blow out the LRU and prevent them from doing too much damage.</ol><li><ol><li>It results in fewer context switches. Data accessed via the InnoDB buffer pool doesn’t require any user/kernel context switches. The worst case behavior is the occurrence of a <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB miss</a>, which is relatively cheap and can be minimized by using <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages</a>.</ol></ol><p><strong>Connection Handling</strong></p><p>MySQL implements concurrent connections by spawning a thread-per-connection. This is relatively low overhead; each thread has some memory overhead for stack space, plus some memory allocated on the heap for connection-specific buffers. It’s not uncommon to scale MySQL to 10,000 or so concurrent connections, and in fact we are close to this connection count on some of our MySQL instances today.</p><p>Postgres, however, use a process-per-connection design. This is significantly more expensive than a thread-per-connection design for a number of reasons. Forking a new process occupies more memory than spawning a new thread. Additionally, IPC is much more expensive between processes than between threads. Postgres 9.2 uses <a href="http://man7.org/linux/man-pages/man7/svipc.7.html">System V IPC</a> primitives for IPC instead of lightweight <a href="http://man7.org/linux/man-pages/man2/futex.2.html">futexes</a> when using threads. Futexes are faster than System V IPC because in the common case where the futex is uncontended, there’s no need to make a context switch.</p><p>Beside the memory and IPC overhead associated with Postgres’s design, Postgres seems to simply have poor support for handling large connection counts, even when there is sufficient memory available. We’ve had significant problems scaling Postgres past a few hundred active connections. While <a href="https://wiki.postgresql.org/wiki/Number_Of_Database_Connections">the documentation is not very specific about why</a>, it does strongly recommend employing an out-of-process connection pooling mechanism to scale to large connection counts with Postgres. Accordingly, using <a href="https://pgbouncer.github.io/">pgbouncer</a> to do connection pooling with Postgres has been generally successful for us. However, we have had occasional application bugs in our backend services that caused them to open more active connections (usually “idle in transaction” connections) than the services ought to be using, and these bugs have caused extended downtimes for us.</p><h1 id="conclusion"><strong>Conclusion</strong></h1><p>Postgres served us well in the early days of Uber, but we ran into significant problems scaling Postgres with our growth. Today, we have some legacy Postgres instances, but the bulk of our databases are either built on top of MySQL (typically using our <a href="https://www.uber.com/blog/schemaless-part-one/">Schemaless</a> layer) or, in some specialized cases, NoSQL databases like Cassandra. We are generally quite happy with MySQL, and we may have more blog articles in the future explaining some of its more advanced uses at Uber.</p><p><em>Evan Klitzke is a staff <a href="https://www.uber.com/careers/list/?city=all&amp;country=all&amp;keywords=software+engineer&amp;subteam=all&amp;team=engineering">software engineer</a> within <a href="https://people.uber.com/eng/">Uber Engineering</a>‘s core infrastructure group. He is also a <a href="https://www.uber.com/blog/tag/database/">database</a> enthusiast and joined Uber as an engineering early bird in September 2012.</em></p><p><a href="https://www.uber.com/en-IN/blog/postgres-to-mysql-migration/">https://www.uber.com/en-IN/blog/postgres-to-mysql-migration/</a></p><p><a href="https://youtu.be/_E43l5EbNI4?si=q9vWT8HjV5NT-M8l">https://youtu.be/_E43l5EbNI4?si=q9vWT8HjV5NT-M8l</a></p><p><a href="/database-engineering-fundamental-part-5/">Back to Parent Page</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/article/'>Article</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/softwareengineering/" class="post-tag no-text-decoration" >softwareengineering</a> <a href="/tags/backenddevelopment/" class="post-tag no-text-decoration" >backenddevelopment</a> <a href="/tags/database-engineering/" class="post-tag no-text-decoration" >database-engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Part+5%3A+Database+Engineering+Fundamentals%3A+Why+Uber+Engineering+Switched+from+Postgres+to+MySQL+-+Pravin+on+Software&url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fwhy-uber-engineering-switched-from-postgres-to-mysql%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Part+5%3A+Database+Engineering+Fundamentals%3A+Why+Uber+Engineering+Switched+from+Postgres+to+MySQL+-+Pravin+on+Software&u=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fwhy-uber-engineering-switched-from-postgres-to-mysql%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fwhy-uber-engineering-switched-from-postgres-to-mysql%2F&text=Part+5%3A+Database+Engineering+Fundamentals%3A+Why+Uber+Engineering+Switched+from+Postgres+to+MySQL+-+Pravin+on+Software" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fwhy-uber-engineering-switched-from-postgres-to-mysql%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/database-engineering-fundamental-part-2/">Part 2: Database Engineering Fundamentals</a><li><a href="/posts/system-design-roadmap/">Comprehensive Roadmap for Low-Level and High-Level Design Interview Preparation</a><li><a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/">Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</a><li><a href="/database-engineering-fundamental-part-1/">Part 1: Database Engineering Fundamentals</a><li><a href="/database-engineering-fundamental-part-1/database-page/">Part 1: Database Engineering Fundamentals: Database Page</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/"><div class="card-body"> <em class="small" data-ts="1720157400" data-df="ll" > Jul 5, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</h3><div class="text-muted small"><p> Write Amplification Problem in PostgreSQL Write Amplification Problem in PostgreSQL The Write Amplification Problem (WAP) typically arises in systems using Solid State Drives (SSDs) or other stor...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/"><div class="card-body"> <em class="small" data-ts="1719775800" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals</h3><div class="text-muted small"><p> Table of Contents ACID Properties Understanding Database Internals Row-Based vs Column-Based Databases Primary Key vs Secondary Key Database Indexing SQL Query Planner and Optimizer ...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/database-page/"><div class="card-body"> <em class="small" data-ts="1719779400" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals: Database Page</h3><div class="text-muted small"><p> Databases Pages (Article) Database Pages — A deep dive Databases often use fixed-size pages to store data. Tables, collections, rows, columns, indexes, sequences, documents and more eventually en...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/database-engineering-fundamental-part-5/wal-redo-and-undo-logs-in-postgres/" class="btn btn-outline-primary" prompt="Older"><p>Part 5: Database Engineering Fundamentals: WAL, Redo and undo logs in postgres</p></a> <a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/" class="btn btn-outline-primary" prompt="Newer"><p>Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://pravin.dev/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/'; this.page.identifier = '/database-engineering-fundamental-part-5/why-uber-engineering-switched-from-postgres-to-mysql/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://pravin-dev.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WP90FFJ6SJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WP90FFJ6SJ'); }); </script>
