<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture" /><meta name="author" content="Pravin Tripathi" /><meta property="og:locale" content="en" /><meta name="description" content="PostgreSQL Process Architecture" /><meta property="og:description" content="PostgreSQL Process Architecture" /><link rel="canonical" href="https://pravin.dev/database-engineering-fundamental-part-5/postgresql-process-architecture/" /><meta property="og:url" content="https://pravin.dev/database-engineering-fundamental-part-5/postgresql-process-architecture/" /><meta property="og:site_name" content="Pravin on Software" /><meta property="og:image" content="https://pravin.dev/header.png" /><meta property="og:image:height" content="900" /><meta property="og:image:width" content="1600" /><meta property="og:image:alt" content="Generated using Copilot" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-05T07:00:00+05:30" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://pravin.dev/header.png" /><meta name="twitter:image:alt" content="Generated using Copilot" /><meta property="twitter:title" content="Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture" /><meta name="twitter:site" content="@pravin_yo" /><meta name="twitter:creator" content="@pravin_yo" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pravin Tripathi","url":"https://www.linkedin.com/in/pravin-r-tripathi"},"dateModified":"2025-03-22T16:02:56+05:30","datePublished":"2024-07-05T07:00:00+05:30","description":"PostgreSQL Process Architecture","headline":"Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture","image":{"width":1600,"height":900,"alt":"Generated using Copilot","url":"https://pravin.dev/header.png","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pravin.dev/database-engineering-fundamental-part-5/postgresql-process-architecture/"},"url":"https://pravin.dev/database-engineering-fundamental-part-5/postgresql-process-architecture/"}</script><title>Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture | Pravin on Software</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Pravin on Software"><meta name="application-name" content="Pravin on Software"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Pravin on Software</a></div><div class="site-subtitle font-italic">My Learning and Experiments in Software Engineering</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/pravinyo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/pravin_yo" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['pravinyo12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Part 5: Database Engineering Fundamentals: PostgreSQL Process Architecture</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1720143000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 5, 2024 </em> </span> <span> Updated <em class="" data-ts="1742639576" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 22, 2025 </em> </span><div class="mt-3 mb-3"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1600 900'%3E%3C/svg%3E" data-src="/assets/img/database-engineering-fundamental-part-5/header.png" class="preview-img bg" alt="Generated using Copilot" width="1600" height="900" data-proofer-ignore><figcaption class="pt-2 pb-2">Generated using Copilot</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2918 words"> <em>16 min</em> read</span></div></div></div><div class="post-content"><h1 id="postgresql-process-architecture">PostgreSQL Process Architecture</h1><p><img data-src="https://miro.medium.com/v2/resize:fit:700/1*ysek1HEB8TpoWVxSVXmOHw@2x.jpeg" alt="" data-proofer-ignore></p><h1 id="postgresql-process-architecture-1"><strong>PostgreSQL Process Architecture</strong></h1><h2 id="creating-a-listener-on-the-backend-application-that-accepts-connections-is-simple-you-listen-on-an-address-port-pair-connection-attempts"><span class="mr-2"><strong>Creating a listener on the backend application that accepts connections is simple. You listen on an address-port pair, connection attempts…</strong></span><a href="#creating-a-listener-on-the-backend-application-that-accepts-connections-is-simple-you-listen-on-an-address-port-pair-connection-attempts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://miro.medium.com/v2/resize:fill:88:88/1*j-h09TiaKTgYsIvVAHPa4Q@2x.jpeg" alt="" data-proofer-ignore></p><p><a href="https://medium.com/@hnasr"><strong>Hussein Nasser</strong>Follow</a></p><p>Creating a listener on the backend application that accepts connections is simple. You listen on an address-port pair, connection attempts to that address and port will get added to an accept queue; The application accepts connections from the queue and start reading the data stream sent on the connection.</p><p>However, what part of your application does the accepting and what part does the reading and what part does the execution? You can architect your application in many ways based on your use cases. I have a medium post just exploring the different options, you may read the story <a href="https://medium.com/@hnasr/threads-and-connections-in-backend-applications-a225eed3eddb">here</a>.</p><p>In this post I explore the PostgreSQL process architecture in details. Please note that the information here is derived from both the Postgres <a href="https://www.postgresql.org/docs/current/index.html">doc</a> and <a href="https://github.com/postgres/postgres/tree/master/src/backend">code</a>. Discussions about scalability and performance are solely based on my opinions.</p><h3 id="postmaster-process"><span class="mr-2"><strong>Postmaster Process</strong></span><a href="#postmaster-process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is the main process that manages everything in Postgres. It creates a listener on the configured interfaces and port (default 5432). It is also responsible for forking other processes to do various tasks.</p><h3 id="backend-process"><span class="mr-2"><strong>Backend Process</strong></span><a href="#backend-process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The postmaster process creates a new “backend” process for every connection it <a href="https://www.postgresql.org/docs/current/connect-estab.html">accepts</a>. The connection is then handed over to the new backend process to perform the reading of the TCP stream, request parsing, SQL query parsing (yes those are different), planning, execution and returning the results. The process uses its local virtual memory for sorting and parsing logic, this memory is controlled by the <em>work_mem</em> parameter.</p><p>The more connections the postmaster accepts the more backend processes are created. The number of user connections is directly proportional to the number of processes which means more resources, memory, CPU usage and context switching. The benefits of course, each process enjoys a dedicated virtual memory space isolated from other processes, so it is great for security especially that each connection is made to a single database.</p><p>The problem with this architecture is scalability. With limited CPU cores, how can Postgres scale to thousands or tens of thousands of client connections on a single CPU? The context switching alone and the competition between all the dedicated backend processes for CPU time will cause processes to starve each other. Worth mentioning while some part of query execution will require the CPU, most of the asynchronous I/O to read and write to buffers/memory and won’t involve the CPU.</p><p>Postgres knows this limitation and that is why the number of backend processes is capped by the number of connections, the <a href="https://www.postgresql.org/docs/15/runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a> parameter defaults to 100 which may look low but we will find out in the next few paragraphs is it actually enough for most cases. Perhaps Postgres set it this low to discourage large number of connections by default (for a good reason).</p><p>You see, backend applications such as web servers and reverse proxies are directly exposed to end-user clients resulting in potentially millions of connections. While the “clients” of Postgres as a database tend to be other web servers and backend applications that are not as verbose and can safely share a pool of connections.</p><blockquote><p>The number of clients of a Web server coming from mobile phones and browsers is much higher than those of a database which is handful of applications that can share connections.</p></blockquote><p>In the next section, we will learn that Postgres has a feature to offload processing to a pool of worker threads known as background workers for parallel processing.</p><h3 id="background-workers"><span class="mr-2"><strong>Background Workers</strong></span><a href="#background-workers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Most proxies, web servers (and even databases e.g. <a href="https://medium.com/@hnasr/memcached-architecture-af3369845c09">memcached</a>) create a handful of processes or threads (often one for every CPU core) and distribute connections among these processes. This keeps context switching to a minimum and allow sharing of resources.</p><p>Spawning a backend process in Postgres for every connection and having that process do the work doesn’t scale in my opinion. Imagine having 1000 connections, the corresponding 1000 backend processes executing client queries and competing for CPU and resources, we are left at the mercy of the operating system scheduler deciding which process gets the CPU, as a result the overall performance of the system will degrade.</p><h3 id="parallel-queries"><span class="mr-2"><strong>Parallel Queries</strong></span><a href="#parallel-queries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In <a href="https://www.postgresql.org/docs/9.6/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">version 9.6</a>, Postgres introduced the parallel queries feature which allowed multiple workers to execute a single query. This allowed for two things:</p><ol><li>Break a single query and execute it on multiple cores in parallel so it completes faster.<li>Delegate the work to a fixed size pool of workers instead of connection-bound backend processes.</ol><p>With parallel queries, the backend process builds a parallel plan and pulls x number of background workers from the pool to execute the plan. While a worker is executing a query it is marked as busy, no other queries can use that process. Even with large number of clients, the limited pool of background workers will serve as a configurable and predictable performance metric which didn’t exist prior to Postgres 9.6.</p><h3 id="pros-and-cons-of-parallel-queries"><span class="mr-2"><strong>Pros and Cons of Parallel Queries</strong></span><a href="#pros-and-cons-of-parallel-queries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Based on the <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">doc</a>, parallel queries can result in higher CPU utilization compared to non-parallel queries with the same number of clients and queries. A single query with joins and nested queries will run on a single process and single CPU core but when broken into parts it will run on multiple cores consuming more CPU. While this is true in normal/low load environment, it is slightly different in high load.</p><p>When all background workers are busy in a high load environment, new parallel queries will have to wait causing only that client to experience the wait delay while the database remain stable. Compare this to when parallel queries are disabled, nothing (as far as I know) stops the backend processes from executing all or any incoming queries, leading to an overall system performance degradation with all the processes competing for CPU and OS context switching. Of course you can limit the number of backend processes with the <em>max_connections</em> parameter to avoid this problem and Postgres does set that to a low value of 100, but then you prevent clients from connecting.</p><blockquote><p>You will notice all my focus here is on a single machine, of course having many read replicas to distribute the load is a good idea when a single machine can’t handle it. But I also believe that we should not rush to distribute until we squeezed every bit of performance from a single machine.</p></blockquote><p>It is a trade-off, few clients will suffer “waits” when all workers are busy, but the waits can be measured, logged, understood and even in some cases tolerated. When we always let the backend process do the work everyone is competing for CPU time and we have little control.</p><blockquote><p>It is imporant to note that parallel queries will only get triggered if the backend process comes up with parallel plan. If the query is simple and the cost seems low the backend process will likely do the work. Parallel queries can be disabled by setting max_parallel_workers_per_gather to zero.</p></blockquote><h3 id="notes-on-background-workers"><span class="mr-2"><strong>Notes on Background workers</strong></span><a href="#notes-on-background-workers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Besides parallel queries, <a href="https://www.postgresql.org/docs/15/glossary.html#GLOSSARY-BACKGROUND-WORKER">background workers</a> are also responsible for logical replication and custom user-code extensions. Just like backend processes, background worker processes have their own virtual memory space mainly used to store the <em>work_mem</em> area which is used for holding data for sorting. It is important to understand that <em>work_mem</em> is per process, so really multiply that for each background worker and backend process.</p><p>The background worker pool is limited by the <em>max_worker_processes</em> parameter which defaults to 8. To me, I would match it to the number of cores on the machine, but we also need to think about the nature of the workload here. Postgres is a database, while it uses the CPU for parsing, planning and sorting, the rest of the work is mostly <a href="https://medium.com/@hnasr/when-nodejs-i-o-blocks-327f8a36fbd4">I/O bound</a> whether that is hitting the memory or disk. Again, each background worker will allocate a <em>work_mem</em> worth of memory in its private virtual memory space.</p><h3 id="auxiliary-processes"><span class="mr-2"><strong>Auxiliary Processes</strong></span><a href="#auxiliary-processes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Aside of query execution, Postgres does routine maintenance and management use auxiliary processes unrelated to background workers for these tasks. Below I illustrate the auxiliary processes in Postgres:</p><h3 id="background-writer-bw"><span class="mr-2"><strong>Background Writer (bw)</strong></span><a href="#background-writer-bw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Noted in my diagram as <em>bw,</em> the Background writer is responsible for flushing dirty pages on the shared buffers to file system. HUGE emphasis on file system and NOT necessary disk. You see, the operating system has a file system in memory cache that holds writes until it has enough for them and flushes all them at once to disk to reduce disk I/O. In case of a crash we <em>may</em> lose those changes that haven’t been flushed to disk, that is why we have fsync O_DIRECT which bypasses all that stuff. Background writer simply writes the dirty pages to the file system cache to free some room in memory buffer for more pages to come in.</p><p>All the processes we talked about so far has their own private virtual memory space not accessable to each other, but they also has access to a shared memory space so that pages can be readable by multiple processes. This way all processes have access to the latest and can detect locks and other changes.</p><p>Whether it is from the backend process via non-parallel or one of the background workers through parallels, queries read pages from disk and put them in the shared buffers, and when they write they write to the pages in memory marking them dirty. The shared buffers size can be configured with the <em>shared_buffer</em> parameter and can get full, so dirty pages have to be written to the file system (and eventually to disk for durability) to free up some space for more pages to get to the shared buffers. The background writer job is to write the dirty pages to file system just to free up space in the shared buffers. There is another process that make sure dirty pages get flushed to disk and that is our next auxiliary process.</p><blockquote><p>You might say isn’t it bad to write changes to memory, what if the database crashed? wouldn’t we lose the changes? Actually no, we also write the changes to WAL and persist that to disk more frequently especially on commit. So even if we crashed we can pull whatever we have on disk and “redo” the changes from WAL to the data pages to get to the final state. Of course we might have also flushed pages with changes from transactions that have since rolled back, in that case Postgres “should” “undo” those changes (but doesn’t). The magic or redo and undo logs. To be frank if the data pages have uncommitted changes from transcations that rolledback it is fine, future queries know to ignore those tuples. This makes postgres start up even faster as UNDO technically is not implemented yet as of writing this post. It doesn’t change the fact that this bloat pages and eventually slows down performance, future vacuums should clean those</p></blockquote><h3 id="checkpointer-cp"><span class="mr-2"><strong>Checkpointer (cp)</strong></span><a href="#checkpointer-cp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The background writer writes the dirty pages from shared buffers to the file system cache to free up shared buffers. While changes to the file system eventually goes to disk, they do stay in the operating system file cache for a while in the hopes pages (OS pages that is) might receive more writes and then OS can flush all them in one I/O to disk. There is a possibility that we might lose pages in the file system cache in case of a crash so databases never relay on file system cache for durabilty.</p><p>There is another auxiliary process called checkpointer, which bypasses the file system cache and enforces that the pages are written to disk. The checkpointer (cp) also creates a checkpoint record that guarantees that at this point the WAL and data files pages are 100% in sync and if we crash we will use that checkpoint as our starting point to redo the changes from the WAL, which also has been flushed to disk.</p><h3 id="startup-process-st"><span class="mr-2"><strong>Startup Process (st)</strong></span><a href="#startup-process-st" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>While discussing the background writer and checkpointer we mentioned in case of crash, Postgres applies the WAL changes to data pages to come back to a consistent state. Well , it is the startup process auxiliary process that redo the changes. I suppose that nothing can be done until the startup process completes. This makes me think that the startup process might run even before the postmaster, I would sure implement it this way so that no one can connect unless I can recover my database.</p><h3 id="logger-lg"><span class="mr-2"><strong>Logger (lg)</strong></span><a href="#logger-lg" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Someone needs to write database events, warnings, errors, and (if you enabled tracing) logging the SQL statements, this is the job of the auxiliary process Logger also called syslogger.</p><h3 id="autovacuum-launcher-avl"><span class="mr-2"><strong>Autovacuum Launcher (avl)</strong></span><a href="#autovacuum-launcher-avl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Another auxiliary process that wakes up and launches autovacuum workers which is a completely different pool to do the vacuum process. Not much info on this process so just adding it for completion. I suppose when autovacuum is disabled the launcher is not spawn nor its workers.</p><h3 id="wal-writer-ww"><span class="mr-2"><strong>WAL writer (ww)</strong></span><a href="#wal-writer-ww" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The WAL (Write-ahead log) lives as WAL records in the shared memory, many processes write to the WAL as transcations takes place. Eventually the WAL has to go into the WAL files on disk not just file system cache, but actually physically on disk for them to be useful. The auxiliary process WAL writer (ww) is responsible to flush the WAL.</p><h3 id="wal-archiver-wa"><span class="mr-2"><strong>WAL archiver (wa)</strong></span><a href="#wal-archiver-wa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Once a checkpoint is created by the checkpointer process, older WAL records can be safely purged. However, for backup, recovery and replication purposes, WAL entries can be archived, the WAL archiver auxiliary process takes car of this.</p><h3 id="wal-receiver-wr"><span class="mr-2"><strong>WAL receiver (wr)</strong></span><a href="#wal-receiver-wr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>It is enough to stream WAL records from primary to standby databases to achieve replications. Data files can be updates accordingly as they are much larger. The auxiliary process WAL receiver runs on the replica to receive these changes and apply them to the pages in memory. It is worth mentioning that any process that understands the replication protocol can also receive WAL records.</p><h3 id="other-processes"><span class="mr-2"><strong>Other Processes</strong></span><a href="#other-processes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I couldn’t find a category where I put these so I created one. Those are processes that are not backend nor auxiliary (don’t ask me why). Let us explore them.</p><h3 id="autovaccume-workers"><span class="mr-2"><strong>Autovaccume workers</strong></span><a href="#autovaccume-workers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Vacuum is the process that cleans up entries in pages that are no longer required, whether dead tuples or those left over from rollbacked transactions. Vacuum also cleans entries in the pages from transcations that didn’t get to commit because of a crash but their changes have made it to the disk by background or checkpointer, a process refered to by undo which the startup process should do but not yet implemented in postgres.</p><p>The Autovacuum workers which are spawned by the autovacuum launcher take care of the vacuuming. The autovacuum workers also perform analyze to update the statistics on all tables and indexes.</p><h3 id="wal-senders"><span class="mr-2"><strong>WAL senders</strong></span><a href="#wal-senders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>According to the postgres doc, these are referred to as special backend process that streams WAL changes to the WAL receiver auxiliary process which we discussed before. You can configure how many WAL senders postgres spins up with max_wal_senders parameter.</p><h3 id="process-vs-thread"><span class="mr-2"><strong>Process vs Thread</strong></span><a href="#process-vs-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To the million dollar question. Why processes and not threads? To be honest I couldn’t find a convincing answer. I wanted to explore the differences between processes and threads here but that will make this post even longer. I rather do that in a new post. Will link it here once authored. Actually do me a favor, highlight this sentence to see how many of you actually reached this section and found this post interesting.</p><p>Until then I’ll summarize what I know, processes are definitely heaver than threads, each process have its own virtual memory, it maintains metadata called PCB (process control block) which includes page table for mapping virtual to physical addresses and any other metadata about the process. The PCB has to be stored in memory and brought into the CPU cache registers do translate virtual memory addresses to physical addresses. Threads on the other hand share the virtual memory space with their parent process and their TCB (thread control block) is much smaller with a pointer to parent process PCB. So your cache hits are much higher with threads than processes.</p><p>The only reason I can find as to why Postgres use processes instead of threads are because threads used to be unstable. This discussion is dated on <a href="https://www.postgresql.org/message-id/1098894087.31930.62.camel@localhost.localdomain">2004</a> but since then threading subsystem in operating system are much more stable of course. The question remain, is it really worth it for postgres to switch to threads instead of processes? To me I don’t think, that will far destabilize postgres and it will take years to implement and even then how much is the benefit really is?</p><p>If I would change something in Postgres its not really the Processes, but the concept of one backend process per connection. We can create a pool of backend processes per database, effectively move the connection pooling from the application down to the database.</p><p>Edit: 6/9/2023 A <a href="https://www.postgresql.org/message-id/31cc6df9-53fe-3cd9-af5b-ac0d801163f4%40iki.fi">Postgres community thread</a> has started to discuss the possiblity of making Postgres multi-threaded.</p><h3 id="summary"><span class="mr-2"><strong>Summary</strong></span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Postgres uses processes for all its operations. In this post I illustrated the process architecture of Postgres and explored all the processes (that I’m aware of). Processes have mainly two categories of process groups, one called backend processes which is directly client facing and get one per connection and do the actual work (unless in parallel), the others are system auxiliary processes which do maintaince and routine tasks. Postgres also have other types of special processes such as autovacuum workers.</p><p>If you enjoyed this post consider checking out my <a href="https://database.husseinnasser.com/">database</a> and <a href="https://backend.husseinnasser.com/">backend engineering</a> courses.</p><p>If you prefer to watch a video of this article</p><p><a href="https://medium.com/tag/postgres">#postgres</a><a href="https://medium.com/tag/database">#database</a><a href="https://medium.com/tag/postgresql">#postgresql</a><a href="https://medium.com/tag/software-architecture">#software-architecture</a><a href="https://medium.com/tag/process-vs-thread">#process-vs-thread</a></p><p><a href="/database-engineering-fundamental-part-5/">Back to Parent Page</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/article/'>Article</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/softwareengineering/" class="post-tag no-text-decoration" >softwareengineering</a> <a href="/tags/backenddevelopment/" class="post-tag no-text-decoration" >backenddevelopment</a> <a href="/tags/database-engineering/" class="post-tag no-text-decoration" >database-engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Part+5%3A+Database+Engineering+Fundamentals%3A+PostgreSQL+Process+Architecture+-+Pravin+on+Software&url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fpostgresql-process-architecture%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Part+5%3A+Database+Engineering+Fundamentals%3A+PostgreSQL+Process+Architecture+-+Pravin+on+Software&u=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fpostgresql-process-architecture%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fpostgresql-process-architecture%2F&text=Part+5%3A+Database+Engineering+Fundamentals%3A+PostgreSQL+Process+Architecture+-+Pravin+on+Software" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpravin.dev%2Fdatabase-engineering-fundamental-part-5%2Fpostgresql-process-architecture%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/database-engineering-fundamental-part-2/">Part 2: Database Engineering Fundamentals</a><li><a href="/posts/system-design-roadmap/">Comprehensive Roadmap for Low-Level and High-Level Design Interview Preparation</a><li><a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/">Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</a><li><a href="/database-engineering-fundamental-part-1/">Part 1: Database Engineering Fundamentals</a><li><a href="/database-engineering-fundamental-part-1/database-page/">Part 1: Database Engineering Fundamentals: Database Page</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/database-engineering-fundamental-part-5/write-amplification-problem-in-postgresql/"><div class="card-body"> <em class="small" data-ts="1720157400" data-df="ll" > Jul 5, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 5: Database Engineering Fundamentals: Write Amplification Problem in PostgreSQL</h3><div class="text-muted small"><p> Write Amplification Problem in PostgreSQL Write Amplification Problem in PostgreSQL The Write Amplification Problem (WAP) typically arises in systems using Solid State Drives (SSDs) or other stor...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/"><div class="card-body"> <em class="small" data-ts="1719775800" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals</h3><div class="text-muted small"><p> Table of Contents ACID Properties Understanding Database Internals Row-Based vs Column-Based Databases Primary Key vs Secondary Key Database Indexing SQL Query Planner and Optimizer ...</p></div></div></a></div><div class="card"> <a href="/database-engineering-fundamental-part-1/database-page/"><div class="card-body"> <em class="small" data-ts="1719779400" data-df="ll" > Jul 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Part 1: Database Engineering Fundamentals: Database Page</h3><div class="text-muted small"><p> Databases Pages (Article) Database Pages — A deep dive Databases often use fixed-size pages to store data. Tables, collections, rows, columns, indexes, sequences, documents and more eventually en...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/database-engineering-fundamental-part-5/postgres-vs-msysql/" class="btn btn-outline-primary" prompt="Older"><p>Part 5: Database Engineering Fundamentals: Postgres vs MySQL</p></a> <a href="/database-engineering-fundamental-part-5/toast-table-in-postgres/" class="btn btn-outline-primary" prompt="Newer"><p>Part 5: Database Engineering Fundamentals: TOAST table in Postgres</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://pravin.dev/database-engineering-fundamental-part-5/postgresql-process-architecture/'; this.page.identifier = '/database-engineering-fundamental-part-5/postgresql-process-architecture/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://pravin-dev.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://www.linkedin.com/in/pravin-r-tripathi">Pravin Tripathi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backenddevelopment/">backenddevelopment</a> <a class="post-tag" href="/tags/softwareengineering/">softwareengineering</a> <a class="post-tag" href="/tags/database-engineering/">database-engineering</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/coding/">coding</a> <a class="post-tag" href="/tags/smells/">smells</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/nodejs/">nodejs</a> <a class="post-tag" href="/tags/softwaredevelopment/">softwaredevelopment</a> <a class="post-tag" href="/tags/aws/">aws</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WP90FFJ6SJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WP90FFJ6SJ'); }); </script>
